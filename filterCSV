#!/usr/bin/env python3
"""
filterCSV - Augments matching CSV files - according to iThoughts requirements

It can set colours for nodes, change their shape, or delete them - if the node
matches any one of a set of criteria the user specifies.

Reads from stdin
Writes to stdout
Commentary to stderr


Command line parameters are pairs of:

1) A specifier. This is a regular expression to match. (A special value 'all' matches
    any value)
2) An action or sequence of actions.

Actions can be:

* A 1 or 2 digit colour number - relative to the top left of iThoughts' colour palette.
* A colour RGB hexadecimal value.  Ex. FFFFFF is black, 000000 is white, FF0000 is red
* 'delete'.
* A shape - as named by iThoughts.
"""

import csv
import re
import sys
from collections import Counter
from string import hexdigits
import xml.etree.ElementTree as ElementTree

# from CSVTree import CSVTree

filterCSV_level = "1.8"
filterCSV_date = "5 August, 2020"


class ParameterParser:
    def getParameters(self):
        matchCriteria = []
        actionsLists = []

        output = []

        # Heading for parameters display
        output.append("\nfilterCSV " + filterCSV_level + " (" + filterCSV_date + ")\n")
        output.append("Criterion".ljust(40, " ") + " Actions")
        output.append("---------".ljust(40, " ") + " -------")

        # Read in pairs of parameters from command line
        parmNumber = 1
        for parmPair in range((len(sys.argv) - 1) // 2):
            # Handle match criterion
            matchCriterion = sys.argv[parmNumber]
            if matchCriterion == "all":
                # This regex is guaranteed to match anything
                matchCriteria.append(re.compile(".*"))
            elif matchCriterion == "none":
                # This regex is guaranteed to match nothing - and to fail quickly
                matchCriteria.append(re.compile("a^"))
            elif matchCriterion.startswith("@"):
                # Pass through a level match criterion
                matchCriteria.append(matchCriterion)
            else:
                # Some other criterion
                matchCriteria.append(re.compile(matchCriterion))

            parmNumber += 1

            # Handle the actions that go with this match criterion
            actionsString = sys.argv[parmNumber].lower().replace(" ", ",")
            actionList = actionsString.split(",")

            # For nextcolour/samecolour and nextshape/sameshape etc rewrite action as
            # the colour number or shape
            for actionNumber in range(len(actionList)):
                action = actionList[actionNumber]
                if action in ("nextcolour", "nextcolor", "nc"):
                    actionList[actionNumber] = str(
                        iThoughtsColours.getNextColourNumber()
                    )
                elif action in ("samecolour", "samecolor", "sc"):
                    actionList[actionNumber] = str(
                        iThoughtsColours.getSameColourNumber()
                    )
                elif action in ("nextshape", "ns"):
                    actionList[actionNumber] = iThoughtsShapes[
                        iThoughtsShapes.getNextShapeNumber()
                    ]
                elif action in ("sameshape", "ss"):
                    actionList[actionNumber] = iThoughtsShapes[
                        iThoughtsShapes.getSameShapeNumber()
                    ]

            # Add actions list to list of actions lists
            actionsLists.append(actionList)

            parmNumber += 1

            output.append(matchCriterion.ljust(40, " ") + " " + actionsString)

        output.append("\n")

        return matchCriteria, actionsLists, output


class TreeReader:
    def detectInputStreamType(self, inputFile):
        firstLine = inputFile[0]
        firstChar = firstLine[0]

        if firstLine.lower().find("level0") > -1:
            return "iThoughtsCSV"
        else:
            for line in inputFile:
                if line.find(",") > -1:
                    return "CSV"

            if firstLine.find(",") > -1:
                return "CSV"
            elif firstChar == "<":
                return "XML"
            elif firstChar in ["#", "*", "-"]:
                return "markdown"
            else:
                return "text"

    @staticmethod
    def injectColumn(CSVArray, columnName):
        # Injects the named column at the beginning of each line,
        # with the heading given by columnName
        for rowNumber, _ in enumerate(CSVArray):
            if rowNumber == 0:
                CSVArray[0].insert(0, columnName)
            else:
                CSVArray[rowNumber].insert(0, "")
        return CSVArray

    def ensureMandatoryColumns(self, csvRows):
        """
        Add columns if they are not already present
        """
        for column in "priority progress icons shape position note colour".split():
            if column not in csvRows[0]:
                csvRows = self.injectColumn(csvRows, column)

        # Ensure all title cells are lower case
        cellNumber = 0
        for cell in csvRows[0]:
            csvRows[0][cellNumber] = cell.lower()
            cellNumber += 1

        # Return the rows and the position of each column
        return (
            csvRows,
            csvRows[0].index("colour"),
            csvRows[0].index("level"),
            csvRows[0].index("note"),
            csvRows[0].index("shape"),
            csvRows[0].index("position"),
            csvRows[0].index("icons"),
            csvRows[0].index("progress"),
            csvRows[0].index("priority"),
        )

    def ensureColumnsPopulated(self, csvRows):
        # Ensures every column in the header row is present in each subsequent row
        minimumColumnCount = len(csvRows[0])
        for rowNumber, row in enumerate(csvRows):
            extraCells = minimumColumnCount - len(row)
            if extraCells > 0:
                csvRows[rowNumber] += [""] * extraCells

        return csvRows

    def readiThoughtsCSVTree(self, inputFile):
        output = []
        # Build a list of rows
        csvRows = [row for row in csv.reader(inputFile)]
        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readNormalCSVTree(self, inputFile):
        output = []

        # Build a list of rows
        csvRows = []
        noteCells = []
        for row in csv.reader(inputFile):
            csvRows.append(row)
            # See if there's another non-blank cell in the row
            nonBlankCells = 0
            lastNonBlankCell = 0
            cellNumber = 0
            for cell in row:
                if cell != "":
                    nonBlankCells += 1
                    lastNonBlankCell = cellNumber
                cellNumber += 1

            # If there's another non-blank cell last such becomes a note
            if nonBlankCells > 1:
                noteCells.append(row[lastNonBlankCell])
            else:
                noteCells.append("")

        # Add a header line
        csvRows.insert(
            0,
            [
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        # Add level column to each row
        rowNumber = 0
        for row in csvRows:
            if rowNumber > 0:
                cellNumber = 0
                for cell in row:
                    if cell != "":
                        break
                    cellNumber += 1
                row.insert(0, cellNumber)
            rowNumber += 1

        # Inject any notes (last blank cell)
        csvRows = self.injectColumn(csvRows, "note")
        noteColumn = csvRows[0].index("note")

        rowNumber = 0
        for row in csvRows:
            if rowNumber > 0:
                row[noteColumn] = noteCells[rowNumber - 1]
            rowNumber += 1

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readMarkdownOrTextTree(self, inputFile):
        output = []

        # Build array of rows
        csvRows = []

        # Work out what an indent would be - in numbers of characters per level,
        # using the first indented line as the template.
        indentLength = 0
        for line in inputFile:
            indentLength = len(line) - len(line.lstrip())
            if indentLength > 0:
                # This is the first line with whitespace at the beginning

                # Save the indentation whitespace
                indentCharacters = line[0:indentLength]

                # Print the detected indentation - so user can debug
                output.append(
                    "Indentation detected: "
                    + formatWhitespaceCharacters(indentCharacters)
                )

                break

        # Insert a header row, with attribute columns and a level0 column plus other
        # levels
        csvRows.append(
            [
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        # Add a level column if one is not already present, and move the text into the
        # right level - for each data line
        for lineNumber, line in enumerate(inputFile):
            # A data line so work out how many levels deep it is indented
            if indentLength > 0:
                lineIndentLength = len(line) - len(line.lstrip())
                if lineIndentLength % indentLength > 0:
                    if lineIndentLength == 1:
                        output.append("Bad indentation: 1 white space character.")
                    else:
                        output.append(
                            "Bad indentation:"
                            + str(lineIndentLength)
                            + " white space characters."
                        )

                    output.append(
                        "Should be multiple of "
                        + str(indentLength)
                        + ". Rounding level down to "
                        + str(lineIndentLength / indentLength)
                        + "."
                    )
                    output.append("Line in error (" + str(lineNumber) + ") is: " + line)
                    output.append(
                        "Leading white space characters: "
                        + formatWhitespaceCharacters(line[0:lineIndentLength])
                    )
                else:
                    lineIndentCharacters = line[0:lineIndentLength]
                    if lineIndentCharacters != indentCharacters * (
                        lineIndentLength // indentLength
                    ):
                        output.append("Bad indentation characters:")
                        output.append(
                            "Line in error (" + str(lineNumber) + ") is: " + line
                        )
                        output.append(
                            "Leading white space characters: "
                            + formatWhitespaceCharacters(lineIndentCharacters)
                        )

            newRow = []

            if indentLength == 0:
                level = 0
            else:
                level = lineIndentLength // indentLength

            newRow.append(str(level))

            # Insert blank cells - according to level
            for lev in range(level):
                newRow.append("")

            # Clean the line text to remove any list item marker
            cleanedLine = line.lstrip().rstrip()
            if cleanedLine[0:2] in ["* ", "- "]:
                cleanedLine = cleanedLine[2:]

            # Add the cleaned line at the appropriate level
            newRow.append(cleanedLine)

            # Add this new row
            csvRows.append(newRow)

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readOPMLTree(self, tree):
        self.XMLNamespaces = {}

        output = ["XML is specifically 'OPML'.\n"]

        if tree[0].tag == "head":
            # Level 0 node will be the contents of the title element within the
            # head element
            titleText = tree[0][0].text.strip()
            haveHead = True

            if (len(tree) > 1) & (tree[1].tag == "body"):
                haveBody = True
                bodyElement = tree[1]
            else:
                haveBody = False
        else:
            haveHead = False

            if tree[0].tag == "body":
                haveBody = True
                bodyElement = tree[0]
            else:
                haveBody = False

        # Build array of rows
        csvRows = []

        # Insert a header row, with attribute columns and a level0 column plus other
        # levels
        csvRows.append(
            [
                "priority",
                "progress",
                "icons",
                "position",
                "colour",
                "shape",
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        if haveHead:
            headCSVRow = ["", "", "", "", "", "", "0", titleText]

            csvRows.append(headCSVRow)

            if haveBody:
                # Any level 1+ elements are children of the body element
                for child in bodyElement:
                    csvRows += self._readOPMLTree(child, 1)
            else:
                # All top-level children of tree, except head, are level 1
                for child in tree:
                    if child.tag != "head":
                        csvRows += self._readOPMLTree(child, 1)
        else:
            # Don't have a head row so have to look for body or top-level outline
            # elements
            if haveBody:
                # All top-level children of body element are level 0
                for child in bodyElement:
                    csvRows += self._readOPMLTree(child, 0)
            else:
                # All top-level children of tree are level 0
                for child in tree:
                    csvRows += self._readOPMLTree(child, 0)

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def _readOPMLTree(self, XMLNode, level):
        csvRows = []
        nodeText = XMLNode.attrib["text"]

        nodeRow = ["", "", "", "", "", "", str(level)]

        levelBlankCells = [""] * (level)
        nodeRow += levelBlankCells

        nodeRow.append(nodeText)
        csvRows.append(nodeRow)

        for child in XMLNode:
            csvRows += self._readOPMLTree(child, level + 1)

        return csvRows

    def readXMLTree(self, inputFile):
        output = []

        # Prepare the input text for namespace parsing and XML parsing
        XMLText = "\n".join(inputFile)

        # Create the XML parse tree
        self.XMLTree = ElementTree.fromstring(XMLText)

        # Check if OPML
        if self.XMLTree.tag == "opml":
            # Is OPML so treat separately from other XML
            return self.readOPMLTree(self.XMLTree)
        else:
            # Is not OPML
            # Hunt for the default namespace
            split1 = XMLText.split('xmlns="')
            if len(split1) == 1:
                output.append("No default namespace specification.")
                self.defaultXMLNamespace = ""
            else:
                self.defaultXMLNamespace = split1[1].split('"')[0]
                output.append(f"Default namespace is '{self.defaultXMLNamespace}'")

            # Hunt for other namespaces
            self.XMLNamespaces = {}
            split3 = XMLText.split("xmlns:")
            for fragment in range(len(split3)):
                if fragment > 0:
                    split4 = split3[fragment].split('="')
                    key = split4[0]
                    split5 = split4[1].split('"')
                    value = split5[0]
                    self.XMLNamespaces[key] = value

            # Build array of rows
            csvRows = []

            # Insert a header row, with attribute columns and a level0 column plus other
            # levels
            csvRows.append(
                [
                    "priority",
                    "progress",
                    "icons",
                    "position",
                    "colour",
                    "shape",
                    "level",
                    "level0",
                    "level1",
                    "level2",
                    "level3",
                    "level4",
                    "level5",
                    "level6",
                    "level7",
                    "level8",
                    "level9",
                    "level10",
                    "level11",
                    "level12",
                    "level13",
                    "level14",
                    "level15",
                    "level16",
                    "level17",
                    "level18",
                    "level19",
                    "level20",
                ],
            )

            csvRows += self._readXMLTree(self.XMLTree, 0)

            return self.ensureMandatoryColumns(csvRows) + (output,)

    def resolveNamespaces(self, textToEdit):
        editedText = textToEdit.replace("{" + self.defaultXMLNamespace + "}", "")
        for key in self.XMLNamespaces:
            editedText = editedText.replace(
                "{" + self.XMLNamespaces[key] + "}", key + ":"
            )
        return editedText

    def _readXMLTree(self, XMLNode, level):
        csvRows = []

        # Edit the element tag - in case of namespaces
        editedElementName = self.resolveNamespaces(XMLNode.tag)

        # Create beginning of the row for the node itself - without attributes

        if XMLNode is self.XMLTree:
            # Is root node so create legend rows before it
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "{-300,-120}",
                    iThoughtsColours.getColour(2),
                    "rectangle",
                    "0",
                    "element",
                ]
            )
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "{-300,-85}",
                    iThoughtsColours.getColour(8),
                    "rectangle",
                    "0",
                    "value",
                ]
            )
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "{-300,-50}",
                    iThoughtsColours.getColour(6),
                    "rectangle",
                    "0",
                    "attribute",
                ]
            )

            # Set position of root node to {0,0}
            elementCSVRow = [
                "",
                "",
                "",
                "{0,0}",
                iThoughtsColours.getColour(2),
                "rounded",
                f"{str(level)}",
            ]
        else:
            # Set position to blank for all but the root node
            elementCSVRow = [
                "",
                "",
                "",
                "",
                iThoughtsColours.getColour(2),
                "rounded",
                f"{str(level)}",
            ]

        # Add blank cells to position the cell with the element in
        if level > 0:
            levelBlankCells = [""] * level
            elementCSVRow += levelBlankCells

        # Add the (edited) element name
        elementCSVRow.append(editedElementName)

        # Add the row to the list of rows
        csvRows.append(elementCSVRow)

        for key, value in XMLNode.attrib.items():
            attributeCSVRow = [
                "",
                "",
                "",
                "",
                iThoughtsColours.getColour(6),
                "rounded",
                f"{str(level + 1)}",
            ]
            levelBlankCells = [""] * (level + 1)
            attributeCSVRow += levelBlankCells

            editedAttributeName = self.resolveNamespaces(key)
            attributeCSVRow += [f'{editedAttributeName}="{value}"']
            csvRows.append(attributeCSVRow)
        if XMLNode.text is not None:
            if XMLNode.text.lstrip().rstrip() != "":
                textCSVRow = [
                    "",
                    "",
                    "",
                    "",
                    iThoughtsColours.getColour(8),
                    "rounded",
                    f"{str(level + 1)}",
                ]
                levelBlankCells = [""] * (level + 1)
                textCSVRow += levelBlankCells
                textCSVRow += [f"{XMLNode.text}"]
                csvRows.append(textCSVRow)

        for child in XMLNode:
            csvRows += self._readXMLTree(child, level + 1)

        return csvRows

    def createCSVArray(self):
        output = []

        # Read in whatever's in stdin - which might not be CSV
        inputFile = sys.stdin.readlines()

        # Detect the input stream type
        inputType = self.detectInputStreamType(inputFile)

        output.append(f"Input type detected as '{inputType}'.\n")

        # Depending on detected input type create a create CSV-like array,
        # including mandatory columns
        if inputType == "iThoughtsCSV":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output1,
            ) = self.readiThoughtsCSVTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output,
            )
        elif inputType == "CSV":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output1,
            ) = self.readNormalCSVTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output,
            )
        elif inputType in ["markdown", "text"]:
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output1,
            ) = self.readMarkdownOrTextTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output,
            )
        elif inputType == "XML":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output1,
            ) = self.readXMLTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)
            if len(self.XMLNamespaces) > 0:
                output.append("Namespace".ljust(20, " ") + " Namespace URL")
                output.append("---------".ljust(20, " ") + " -------------")
                for key in self.XMLNamespaces:
                    output.append(key.ljust(20, " ") + " " + self.XMLNamespaces[key])
                output.append("")

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                output,
            )


class TreeWriter:
    def writeTreeAsCSV(self):
        # Write the tree out as a CSV file in iThoughts format
        CSVwriter = csv.writer(sys.stdout, quoting=csv.QUOTE_ALL)

        # Write the header row
        headerRow = [
            "priority",
            "progress",
            "icons",
            "colour",
            "note",
            "position",
            "shape",
            "level",
        ]

        # Establish how many levels to put out in the heading
        levels = csvTree.calculateMaximumLevel() + 1

        for level in range(levels):
            headerRow.append("level" + str(level))

        CSVwriter.writerow(headerRow)

        # Write out the resulting CSV data
        outputArray = []
        outputArray = csvTree.writeCSVTree(outputArray)

        for row in outputArray:
            CSVwriter.writerow(row)


class iThoughtsColours:
    light_pastel = """FFB2B2 FFD8B2 FFFFB2 D8FFB2 B2FFB2 B2FFD8
                      B2FFFF B2D8FF B2B2FF D8B2FF FFB2FF FFB2D8""".split()

    dark_pastel = """B24747 B27C47 B2B247 7CB247 47B247 47B27C
                     47B2B2 477CB2 4747B2 7C47B2 B247B2 B2477C""".split()

    saturated = """FF0000 FF7F00 FFFF00 7FFF00 00FF00 00FF7F
                   00FFFF 007FFF 0000FF 7F00FF FF00FF FF007F""".split()

    grayscale = """000000 929292 a9a9a9 C0C0C0 D6D6D6 FFFFFF""".split()

    solarized = """002b36 073642 586e75 657b83 839496 93a1a1
                   eee8d5 fdf6e3 b58900 cb4b16 dc322f d33682
                   6c71c4 268bd2 2aa198 859900""".split()
    colours = light_pastel + dark_pastel + saturated + grayscale + solarized

    colourNumber = 0

    def __getitem__(self, key):
        """
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours[0]
        'FFB2B2'
        >>> ithoughts_colours[-1]
        '859900'
        """
        return self.colours[key]

    def getColour(self, colourNumber):
        """Get colour based on colour number (which starts at 1)
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getColour(1)
        'FFB2B2'
        >>> ithoughts_colours.getColour(58)
        '859900'
        """
        return self[colourNumber - 1]

    def __len__(self):
        """
        >>> len(iThoughtsColours())
        58
        """
        return len(self.colours)

    def getNextColourNumber(self):
        """Get the next colour number from the iThoughts palette
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getNextColourNumber()
        1
        """
        self.colourNumber += 1
        return self.colourNumber

    def getSameColourNumber(self):
        """Get the same colour number from the iThoughts palette
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getSameColourNumber()
        0
        """
        return self.colourNumber


class iThoughtsShapes:
    # Shapes as understood by iThoughts
    shapes = (
        "auto",
        "rectangle",
        "square",
        "rounded",
        "pill",
        "parallelogram",
        "diamond",
        "triangle",
        "oval",
        "circle",
        "underline",
        "none",
        "square bracket",
        "curved bracket",
    )

    shapeNumber = 0

    def __contains__(self, item):
        """Is item in self.shapes
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> all(shape in ithoughts_shapes for shape
        ...     in ('auto', 'triangle', 'none', 'curved bracket'))
        True
        """
        return item in self.shapes

    def __getitem__(self, key):
        """Get shape based on shape number (which starts at 0)
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes[0]
        'auto'
        >>> ithoughts_shapes[-1]
        'curved bracket'
        """
        return self.shapes[key]

    def __len__(self):
        """
        >>> len(iThoughtsShapes())
        14
        """
        return len(self.shapes)

    def getNextShapeNumber(self):
        """Get the next shape number from the iThoughts list
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes.getNextShapeNumber()
        1
        """
        self.shapeNumber += 1
        return self.shapeNumber

    def getSameShapeNumber(self):
        """Get the same shape number from the iThoughts list
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes.getSameShapeNumber()
        0
        """
        return self.shapeNumber


class iThoughtsIcons:
    # icons as understood by iThoughts
    icons = (
        "tick",
        "tickbox",
        "p0",
        "p1",
        "p2",
        "p3",
        "p4",
        "p5",
        "p6",
        "p7",
        "p8",
        "p9",
        "signal-flag-red",
        "signal-flag-yellow",
        "signal-flag-green",
        "icon-signal-flag-black",
        "icon-signal-flag-blue",
        "icon-signal-flag-orange",
        "icon-signal-flag-purple",
        "icon-signal-flag-white",
        "icon-signal-flag-checkered",
        "icon-hat-black",
        "icon-hat-blue",
        "icon-hat-green",
        "icon-hat-red",
        "icon-hat-white",
        "icon-hat-yellow",
        "icon-calendar1",
        "icon-calendar7",
        "icon-calendar12",
        "icon-calendar31",
        "icon-calendar52",
        "arrow-down-blue",
        "arrow-left-blue",
        "arrow-right-blue",
        "arrow-up-blue",
        "arrow-up-green",
        "arrow-down-red",
        "stop",
        "prep",
        "go",
        "smiley_happy",
        "icon-smiley-neutral",
        "smiley_sad",
        "icon-money",
        "currency-dollar",
        "currency-euro",
        "currency-pound",
        "currency-yen",
        "icon-currency-won",
        "icon-currency-yuan",
        "hand-yellow-card",
        "hand-red-card",
        "hand-stop",
        "hand-thumb-down",
        "hand-thumb-up",
        "question",
        "icon-questionmark",
        "icon-information",
        "icon-exclamationmark",
        "alert",
        "icon-add",
        "cross",
        "sign-forbidden",
        "sign-stop",
        "idea",
        "icon-camera",
        "auction-hammer",
        "bell",
        "bomb",
        "dynamite",
        "fire",
        "hourglass",
        "target",
        "view",
        "icon-airplane",
        "icon-alarmclock",
        "icon-bug",
        "icon-businessmen",
        "icon-car",
        "icon-clients",
        "icon-cup",
        "icon-data",
        "icon-desktop",
        "icon-earth",
        "icon-flash",
        "icon-gear",
        "icon-heart",
        "icon-key",
        "icon-lock-open",
        "icon-lock",
        "icon-mail",
        "icon-pin",
        "icon-printer",
        "icon-scales",
        "icon-star",
        "icom-telephone",
        "icon-pencil",
        "icon-alarm",
        "icon-book",
        "icon-certificate",
        "icon-cloud",
        "icon-compasses",
        "icon-dice",
        "icon-folder",
        "icon-document",
        "icon-male",
        "icon-female",
        "icon-newspaper",
        "icon-paperclip",
        "icon-presentation",
        "icon-signpost",
        "icon-step",
    )

    def __contains__(self, item):
        return item in self.icons


class iThoughtsSpread:
    horizontalPosition = 0
    horizontalIncrement = 0
    verticalPosition = 0
    verticalIncrement = 0

    def resetHorizontalSpread(self, horizontalIncrement):
        self.horizontalPosition = 0
        self.horizontalIncrement = horizontalIncrement

    def nextHorizontal(self):
        x = self.horizontalPosition
        self.horizontalPosition += self.horizontalIncrement
        return x

    def resetVerticalSpread(self, verticalIncrement):
        self.verticalPosition = 0
        self.verticalIncrement = verticalIncrement

    def nextVertical(self):
        y = self.verticalPosition
        self.verticalPosition += self.verticalIncrement
        return y

    def getNextPosition(self):
        return self.nextHorizontal(), self.nextVertical()


class CSVTree:
    def __init__(
        self, priority, progress, icons, shape, colour, note, level, position, cell
    ):
        """
        >>> csv_tree = CSVTree("priority", "progress", "icons","shape", "colour", "note", "level", 1, "cell")
        >>> csv_tree.data["shape"]
        'shape'
        """
        self.toBeDeleted = False
        self.childNodes = []
        self.data = {
            "priority": priority,
            "progress": progress,
            "icons": icons,
            "shape": shape,
            "colour": colour,
            "note": note,
            "level": level,
            "position": position,
            "cell": cell,
        }
        self.parent = None
        self.matched = False

    def addChild(self, childNode):
        self.childNodes.append(childNode)
        childNode.parent = self
        return childNode

    def deleteChild(self, childNode):
        self.childNodes.remove(childNode)

    def cleanUpDeleted(self):
        # Actually remove nodes marked for deletion
        # Propagate to children in reverse order - for tree traversal to work
        for c in range(len(self.childNodes) - 1, -1, -1):
            self.childNodes[c].cleanUpDeleted()

        # Now remove this node - if to be deleted
        if self.toBeDeleted:
            self.parent.deleteChild(self)

    def getChildren(self):
        return self.childNodes

    def replaceChild(self, childNode, replacementChildren):
        # Remove the child node having replaced it with the replacement
        # children, which are a list. (List could contain 1 item, of course.)
        if childNode in self.childNodes:
            # Child node is indeed a child so find its index
            childIndex = self.childNodes.index(childNode)

            # Insert each item from the replacement list before the child
            for i in range(len(replacementChildren)):
                self.childNodes.insert(i + childIndex - 1, replacementChildren[i])

            # Mark the node that's been replaced to be deleted
            childNode.toBeDeleted = True

            # Fix up the tree levels - from root downwards
            # self.repairSubtreeLevels(int(self.data["level"])-1)
        else:
            # Supposed child node isn't a child of this CSVTree object
            sys.stderr.write(
                childNode.data["cell"]
                + " is not a child of "
                + self.data["cell"]
                + "\n"
            )

    def isMatch(self, criterion):
        """
        Common method for establishing if a node matches some criterion, usually a regex
        """
        return (
            (re.search(criterion, self.data["icons"]) is not None)
            | (re.search(criterion, self.data["shape"]) is not None)
            | (re.search(criterion, self.data["colour"]) is not None)
            | (re.search(criterion, self.data["note"]) is not None)
            | (re.search(criterion, self.data["cell"]) is not None)
        )

    def applyAction(self, criterion, action, propagateToChildren):
        if action == "delete":
            # Mark the node for deletion
            self.toBeDeleted = True

            # Don't propagate
            propagateToChildren = False
        elif action == "asbullet":
            self.makeAsBulletOfParent()
        elif action == "reverse":
            self.reverseChildren()
        elif action == "sort":
            self.sortChildren()
        elif action[0] == "{":
            # position specified
            self.data["position"] = action

            # Don't propagate
            propagateToChildren = False
        elif action == "note":
            # Document the match in the note field
            if isinstance(criterion, str):
                criterionString = criterion
            else:
                criterionString = criterion.pattern

            if self.data["note"] != "":
                self.data["note"] += "\nMatched " + criterionString
            else:
                self.data["note"] = "Matched " + criterionString
        elif action == "noshape":
            # Remove any shape specification from the matched node
            self.data["shape"] = ""
        elif action == "nonote":
            # Remove any note specification from the matched node
            self.data["note"] = ""
        elif action == "noposition":
            # Remove any position specification from the matched node
            self.data["position"] = ""
        elif action == "nocolour":
            # Remove any colour specification from the matched node
            self.data["colour"] = ""
        elif len(action) == 6 and all(c in hexdigits for c in action):
            # 6-digit hexadecimal so is colour RGB value
            self.data["colour"] = action
        elif action in iThoughtsShapes:
            # Is a shape
            self.data["shape"] = action
        elif action[0:9] == "priority:":
            if action[9:].isdigit():
                self.data["priority"] = action[9:]
            else:
                sys.stderr.write(
                    f"Erroneous priority value {action[9:]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )
        elif action[0:5] == "prio:":
            if action[5].isdigit():
                self.data["priority"] = action[5]
            else:
                sys.stderr.write(
                    f"Erroneous priority value {action[5]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )
        elif action in ["noprio", "nopriority"]:
            self.data["priority"] = ""
        elif action[0:9] == "progress:":
            if action[9:].isdigit():
                self.data["progress"] = action[9:]
            else:
                sys.stderr.write(
                    f"Erroneous progress value {action[9:]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )
        elif action[0:5] == "prog:":
            if action[5].isdigit():
                self.data["progress"] = action[5]
            else:
                sys.stderr.write(
                    f"Erroneous progress value {action[5]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )
        elif action in ["noprog", "noprogress"]:
            self.data["progress"] = ""
        elif action in iThoughtsIcons:
            # Is an icons
            if self.data["icons"] == "":
                self.data["icons"] = action
            else:
                self.data["icons"] += "," + action
        elif action == "noicons":
            self.data["icons"] = ""
        elif action.isdigit():
            # Attempt to parse as from the colour palette
            colourNumber = int(action)

            # We have an integer. If it is too big but not 6 digits
            # we flag an error and don't do the update
            if colourNumber > len(iThoughtsColours):
                sys.stderr.write(
                    f"Erroneous colour value {colourNumber} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )

            else:
                self.data["colour"] = iThoughtsColours.getColour(colourNumber)
        else:
            sys.stderr.write(
                f"Erroneous action value {action} "
                f"(Pattern was: '{criterion.pattern}')." + "\n"
            )
        return propagateToChildren

    def applyActions(self, criterion, actionsList):
        """
        Apply filter to this node - if not tree root
        """
        propagateToChildren = True
        if self.data["level"] != -1:
            if isinstance(criterion, str):
                if criterion.startswith("@level:"):
                    potentialLevelString = criterion[7:].rstrip()
                    if potentialLevelString.isdigit():
                        wantedLevel = int(potentialLevelString)
                        if self.data["level"] == wantedLevel:
                            # We have a node at the right level
                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )
                    else:
                        # The level specified wasn't an integer
                        print(f"Bad level string '{potentialLevelString}")
                elif criterion.startswith("@priority:") | criterion.startswith(
                    "@prio:"
                ):
                    if criterion.startswith("@priority:"):
                        potentialPriorityString = criterion[10:].rstrip()
                    else:
                        potentialPriorityString = criterion[6:].rstrip()
                    if potentialPriorityString.isdigit():
                        wantedPriority = int(potentialPriorityString)
                        if self.data["priority"] == potentialPriorityString:
                            # We have a node with the right priority
                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )
                elif criterion in ["@nopriority", "@noprio"]:
                    if self.data["priority"] == "":
                        # We have a node with no priority
                        for action in actionsList:
                            propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )
                elif criterion.startswith("@progress:") | criterion.startswith(
                    "@prog:"
                ):
                    if criterion.startswith("@progress:"):
                        potentialProgressString = criterion[10:].rstrip()
                    else:
                        potentialProgressString = criterion[6:].rstrip()
                    if potentialProgressString.isdigit():
                        wantedProgress = int(potentialProgressString)
                        if self.data["progress"] == potentialProgressString:
                            # We have a node with the right progress
                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )
                elif criterion in ["@noprogress", "@noprog"]:
                    if self.data["progress"] == "":
                        # We have a node with no progress
                        for action in actionsList:
                            propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )
                else:
                    # Criterion is a regular expression rather than a string
                    print(f"Bad criterion: '{criterion}'.")
            elif self.isMatch(criterion):
                # Matched so apply all actions triggered by this match
                for action in actionsList:
                    propagateToChildren = self.applyAction(
                        criterion, action, propagateToChildren
                    )

        # Apply filter to children, recursively - if propagation is indicated
        if propagateToChildren:
            for child in self.childNodes:
                child.applyActions(criterion, actionsList)

    def writeCSVTree(self, outputArray):
        # Compose this node's line - if not root node
        level = int(self.data["level"])
        if level > -1:
            line = [
                self.data[key]
                for key in "priority progress icons colour note position shape level".split()
            ]
            line += [""] * int(self.data["level"])
            line.append(self.data["cell"])
            outputArray.append(line)

        # Print children, recursively
        for child in self.childNodes:
            child.writeCSVTree(outputArray)

        return outputArray

    def getCounter(self, counter=None):
        """
        >>> csv_tree = CSVTree("icons", "shape", "colour", "note", 1, 1, "cell")
        >>> csv_tree.getCounter()
        Counter({1: 1})
        >>> _ = csv_tree.addChild(CSVTree("icons", "shape", "colour", "note", 2, 7, "cell"))
        >>> csv_tree.getCounter()
        Counter({1: 1, 2: 1})
        """
        counter = counter or Counter()
        counter[self.data["level"]] += 1
        for child in self.childNodes:
            child.getCounter(counter)
        return counter

    def checkHierarchy(self, actionsList):
        sys.stderr.write("Beginning Level Check\n")
        sys.stderr.write("---------------------\n")

        self._checkHierarchy(-2, actionsList)

        sys.stderr.write("---------------------\n")
        sys.stderr.write("Completed Level Check\n")

    def _checkHierarchy(self, previousLevel, actionsList):
        level = int(self.data["level"])
        if level > previousLevel + 1:
            sys.stderr.write(self.data["cell"].ljust(40) + " Error: ")
            sys.stderr.write(f"Expected level {previousLevel + 1}.")
            sys.stderr.write(f" Found level {level}. ")

            firstAction = actionsList[0]

            if firstAction in ("repair", "repairnode"):
                # Repair just this node
                self.data["level"] = previousLevel + 1
                sys.stderr.write(
                    f"Repaired, setting level to {previousLevel + 1}." + "\n"
                )
            elif firstAction == "repairsubtree":
                # Repair the whole subtree
                sys.stderr.write(
                    "Repaired this node (setting its level to "
                    f"{previousLevel + 1}) and all its child nodes." + "\n"
                )
                self.repairSubtreeLevels(previousLevel)
            elif firstAction == "stop":
                # Terminate the check
                sys.stderr.write("Terminating.\n")
                sys.exit()
            else:
                sys.stderr.write("\n")
        else:
            if previousLevel > -2:
                sys.stderr.write(self.data["cell"].ljust(40) + " OK:   ")
                sys.stderr.write(f" Found level {level}." + "\n")
        for childNode in self.childNodes:
            childNode._checkHierarchy(previousLevel + 1, actionsList)

    def repairSubtreeLevels(self, parentLevel):
        # Repair this level
        self.data["level"] = str(parentLevel + 1)

        # Repair lower levels
        for childNode in self.childNodes:
            childNode.repairSubtreeLevels(parentLevel + 1)

    def exportToMarkdown(self, actionsList):
        # Get the number of heading levels to allow before going to nested bulleted
        # lists
        headingLevels = int(actionsList[0])

        if len(actionsList) > 1:
            # Get first heading level
            startingLevel = int(actionsList[1])
        else:
            # Default to starting at heading level 1
            startingLevel = 1

        return self._exportToMarkdown(headingLevels - 1, startingLevel)

    def _exportToMarkdown(self, maxHeadingLevel, startingLevel):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])
        if level > -1:
            note = self.data["note"]
            if level > maxHeadingLevel:
                output.append(
                    "  " * (level - maxHeadingLevel - startingLevel + 2)
                    + "* "
                    + self.data["cell"]
                )
                if note:
                    output.append(f"<br/><br/>{note}" + "\n")
            else:
                output.append(
                    "\n"
                    + "#" * (level + startingLevel)
                    + " "
                    + self.data["cell"]
                    + "\n"
                )
                if note:
                    output.append(note + "\n")

        for childNode in self.childNodes:
            output += childNode._exportToMarkdown(maxHeadingLevel, startingLevel)

        return output

    def exportToDotDigraph(self, actionsList):
        # Get the number of heading levels to allow before going to nested bulleted
        output, dummy = self._exportToDotDigraph(-1, 0)

        if actionsList[0][0:1] == "v":
            graphAttributes = "\n rankdir=TB"
        else:
            graphAttributes = "\n  rankdir=LR"

        output = ["digraph {" + graphAttributes] + output + ["}"]
        return output

    def _exportToDotDigraph(self, parentItemNumber, thisItemNumber):
        # Prime array of output lines
        output = []

        if thisItemNumber > 0:
            attributes = 'label="' + self.data["cell"] + '"'

            colour = self.data["colour"] or "FFFFFF"
            if colour == "FFFFFF":
                wantFilled = False
            else:
                wantFilled = True
                attributes = attributes + ',fillcolor="#' + colour + '"'

            shape = self.data["shape"]
            wantRounded = False
            if shape != "":
                if shape == "auto":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "rectangle":
                    attributes = attributes + ',shape="rectangle"'
                elif shape == "square":
                    attributes = attributes + ',shape="square"'
                elif shape == "rounded":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "pill":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "parallelogram":
                    attributes = attributes + ',shape="parallelogram"'
                elif shape == "diamond":
                    attributes = attributes + ',shape="diamond"'
                elif shape == "triangle":
                    attributes = attributes + ',shape="triangle"'
                elif shape == "oval":
                    attributes = attributes + ',shape="oval"'
                elif shape == "circle":
                    attributes = attributes + ',shape="circle"'
                elif shape == "underline":
                    attributes = attributes + ',shape="underline"'
                elif shape == "none":
                    attributes = attributes + ',shape="none"'
                elif shape == "square bracket":
                    attributes = attributes + ',shape="rectangle"'
                elif shape == "round bracket":
                    attributes = attributes + ',shape="ellipse"'
                else:
                    attributes = attributes + ',shape="rectangle"'

            if wantRounded | wantFilled:
                styles = []
                if wantRounded:
                    styles.append("rounded")
                if wantFilled:
                    styles.append("filled")
                attributes = attributes + ',style="' + ",".join(styles) + '"'

            output.append("  N" + str(thisItemNumber) + "[" + attributes + "]")
            if parentItemNumber > 0:
                output.append(
                    "  N" + str(parentItemNumber) + " -> N" + str(thisItemNumber)
                )

        nextItemNumber = thisItemNumber + 1
        for childNode in self.childNodes:
            returnedOutput, nextItemNumber = childNode._exportToDotDigraph(
                thisItemNumber, nextItemNumber
            )
            output += returnedOutput

        return output, nextItemNumber

    def calculateMaximumLevel(self, level=0):
        """
        maximum level is the max of this level and the levels of all childNodes,
        recursively through their descendents
        """
        thisLevel = int(self.data["level"])
        if thisLevel > level:
            level = thisLevel
        for childNode in self.childNodes:
            level = childNode.calculateMaximumLevel(level)
        return level

    def exportToHTML(self, actionsList):
        action = actionsList[0]

        # Prime array of output lines
        output = []

        if action == "table":
            # Work out how many levels are needed
            maximumLevel = self.calculateMaximumLevel()

            # Write table start
            output.append("<table>")

            # Write table rows
            output += self._exportToHTMLTable(maximumLevel, action)

            # Write table end
            output.append("</table>")
        else:
            # Write top-level list start
            output.append("<ul style='list-style-type: none;'>")

            # Write nested list
            level, freshOutput = self._exportToHTMLList(action)

            output += freshOutput

            # Write top-level list stop
            output.append("</ul>")

        return output

    def _exportToHTMLTable(self, maximumLevel, action):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])
        # Determine the cell background colour
        colour = self.data["colour"] or "FFFFFF"
        # HTML table
        if level > -1:
            # Print table row start
            output.append("<tr>")

            # Print padding empty columns after the cell's column
            if level > 0:
                output.append("<td></td>" * level)

            # Print the cell itself, including styling
            output.append(
                "<td style='border: 1px solid black;border-radius: 5px;"
                + "background-color: #"
                + colour
                + ";'>"
                + self.data["cell"]
                + "</td>"
            )

            # Print padding empty columns after the cell's column
            if level < maximumLevel:
                output.append("<td></td>" * (maximumLevel - level))

            # Print any note as a final column
            note = self.data["note"]
            if note:
                output.append("<td>" + note + "</td>")

            # Print table row end
            output.append("</tr>")

        for childNode in self.childNodes:
            output += childNode._exportToHTMLTable(maximumLevel, action)

        return output

    def _exportToHTMLList(self, action):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        # Determine the cell background colour
        colour = self.data["colour"]
        if colour == "":
            colour = "FFFFFF"

        # Determine if there is a note
        note = self.data["note"]

        # HTML nested list
        if level > -1:
            indent = "  " * (level + 1)
            # print list item
            output.append(
                indent
                + "<li style='padding: 10px;'><span style='border: 1px solid "
                + "black;padding: 5px;border-radius: 5px;background-color: #"
                + colour
                + ";'>"
                + self.data["cell"]
                + "</span>"
            )

            # Print any note
            if note:
                output.append(indent + "  <br/><br/>" + note)

            needListElements = len(self.childNodes) > 0
            if needListElements is True:
                output.append(indent + "<ul style='list-style-type: none;'>")

        returnedLevel = -2
        for childNode in self.childNodes:
            returnedLevel, freshOutput = childNode._exportToHTMLList(action)

            output += freshOutput

        if level > -1:
            if needListElements is True:
                output.append(indent + "</ul>")

            output.append(indent + "</li>")

        return [level, output]

    def exportToXML(self, actionsList):
        action = actionsList[0]

        if action == "freemind":
            # Freemind XML export
            return self.exportToFreemindXML(actionsList)
        elif action == "opml":
            return self.exportToOPMLXML(actionsList)

    def exportToFreemindXML(self, actionsList):
        # Export to XML in the format Freemind, MindNode and iThoughts accept

        # Prime array of output lines
        output = []

        # Warn if resulting XML would produce more than 1 Level 0 node
        if len(self.childNodes) > 1:
            sys.stderr.write(
                "Exported XML will have more than 1 root node. Some programs will get "
                "confused by this. Continuing.\n"
            )

        # Start the map
        output.append("<?xml version='1.0'?>")
        output.append("<map>")

        # Recursively print the nodes
        output += self._exportToFreemindXML(actionsList)

        # Finish the map
        output.append("</map>")

        return output

    def _exportToFreemindXML(self, actionslist):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        if level > -1:
            # Print this node
            colour = self.data["colour"]
            cell = self.data["cell"]
            note = self.data["note"]
            indent = "  " * (level + 1)
            if colour == "":
                output.append(indent + "<node TEXT='" + cell + "'>")
            else:
                output.append(
                    indent
                    + "<node BACKGROUND_COLOR='#"
                    + colour
                    + "' TEXT='"
                    + cell
                    + "'>"
                )

            if note:
                output.append(indent + "  <richcontent TYPE='NOTE'><html>")
                output.append(indent + "    <head></head>")
                output.append(indent + "    <body>")
                output.append(indent + "      <p>")
                output.append(indent + "        " + note)
                output.append(indent + "      </p>")
                output.append(indent + "    </body>")

                output.append(indent + "  </richcontent>")

        for childNode in self.childNodes:
            output += childNode._exportToFreemindXML(actionsList)

        if level > -1:
            output.append(indent + "</node>")

        return output

    def exportToOPMLXML(self, actionsList):
        # Export to OPML XML

        # Prime array of output lines
        output = []

        # Warn if resulting XML would produce more than 1 Level 0 node
        if len(self.childNodes) > 1:
            sys.stderr.write(
                "Exported XML will have more than 1 root node. Some programs will get "
                "confused by this. Continuing.\n"
            )

        # Start the map
        output.append("<?xml version='1.0'?>")
        output.append("<opml version='2.0'>")
        output.append("  <head>")
        output.append("  </head>")
        output.append("  <body>")

        # Recursively output.append the nodes
        output += self._exportToOPMLXML(actionsList)

        # Finish the map
        output.append("  </body>")
        output.append("</opml>")

        return output

    def _exportToOPMLXML(self, actionslist):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        if level > -1:
            # Print this node
            colour = self.data["colour"]
            cell = self.data["cell"]
            note = self.data["note"]
            indent = "  " * (level + 2)
            if colour == "":
                printLine = indent + "<outline text='" + cell + "'"
            else:
                printLine = (
                    indent
                    + "<outline BACKGROUND_COLOR='#"
                    + colour
                    + "' text='"
                    + cell
                    + "'"
                )

            if note:
                printLine = printLine + " Note='" + note + "'"

            output.append(printLine + ">")

        for childNode in self.childNodes:
            output += childNode._exportToOPMLXML(actionsList)

        if level > -1:
            output.append(indent + "</outline>")

        return output

    def processKeep(self, matchCriterion):
        # Reset all nodes' matched flags
        self._markUnmatched()

        # Apply tests to each node and mark it and all its children and ancestors
        # matched
        self._processKeep(matchCriterion)

        # Delete any unmatched nodes
        self._deleteUnmarked()

    def _markUnmatched(self):
        self.matched = False

        for childNode in self.childNodes:
            childNode._markUnmatched()

    def _markAncestorsMatched(self):
        if self.data["level"] > -1:
            self.matched = True
            self.parent._markAncestorsMatched()

    def _markSubtreeMatched(self):
        self.matched = True
        for childNode in self.childNodes:
            childNode._markSubtreeMatched()

    def _processKeep(self, matchCriterion):
        if self.isMatch(matchCriterion) is True:
            # mark self and all the ancestors matched
            self._markAncestorsMatched()

            # mark self and its subtree matched
            self._markSubtreeMatched()
        else:
            # Maybe children etc are matches
            for childNode in self.childNodes:
                childNode._processKeep(matchCriterion)

    def _deleteUnmarked(self):
        for childNode in self.childNodes:
            childNode._deleteUnmarked()
        if self.data["level"] > -1:
            if not self.matched:
                self.parent.deleteChild(self)

    def promoteLevel(self, actionslist):
        # Promote everything at the specified level, deleting parents
        promotedLevel = int(actionslist[0])
        if promotedLevel < 1:
            sys.stderr.write("Cannot promote level " + str(promotedLevel) + "\n")
            sys.exit()

        # Get nodes to promote
        nodesToPromote = self.findNodesAtLevel(promotedLevel)

        # Get their parents, removing duplicates
        parentsToDelete = []
        for node in nodesToPromote:
            if node.parent not in parentsToDelete:
                parentsToDelete.append(node.parent)

        # Promote each parent's children
        for parent in parentsToDelete:
            # Insert each child in turn
            parentsParent = parent.parent
            for childNode in parent.childNodes:
                parentsParent.addChild(childNode)

            # Delete the parent
            parentsParent.deleteChild(parent)

        # Repair all the levels in the tree
        self.repairSubtreeLevels(-2)

    def findNodesAtLevel(self, level):
        # returns a list of nodes at a particular level
        return self._findNodesAtLevel(level, [])

    def _findNodesAtLevel(self, level, nodes):
        # recursive helper routine to search the tree for nodes at a certain level
        if self.data["level"] == level:
            nodes.append(self)
        else:
            for childNode in self.childNodes:
                nodes = childNode._findNodesAtLevel(level, nodes)

        return nodes

    def writeStatistics(self, actionslist):
        # Write statistics in one of a number of formats

        # Prime array of output lines
        output = []

        # Get the statistics array
        statistics = self.getStatistics()

        # Output the statistics in the right format
        firstAction = actionslist[0]
        if firstAction == "csv":
            output.append("'Level','Nodes','Distinct Nodes'")

            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    str(level) + "," + str(levelNodes) + "," + str(distinctLevelNodes)
                )
        elif firstAction == "html":
            output.append("<table>")
            output.append(
                "<tr>\n<th>Level</th>\n<th>Nodes</th>\n<th>Distinct Nodes</th>\n</tr>"
            )
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append("<tr>")
                output.append("<td>" + str(level) + "</td>")
                output.append("<td>" + str(levelNodes) + "</td>")
                output.append("<td>" + str(distinctLevelNodes) + "</td>")
                output.append("</tr>")
            output.append("</table>")
        elif firstAction == "markdown":
            output.append("|Level|Nodes|Distinct Nodes|")
            output.append("|-:|-:|-:|")
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    "|"
                    + str(level)
                    + "|"
                    + str(levelNodes)
                    + "|"
                    + str(distinctLevelNodes)
                    + "|"
                )
        elif firstAction == "text":
            output.append("Level Nodes Distinct Nodes")
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    str(level).rjust(5, " ")
                    + " "
                    + str(levelNodes).rjust(5, " ")
                    + " "
                    + str(distinctLevelNodes).rjust(14, " ")
                )
        else:
            sys.stderr.write("Invalid format for 'stats': " + firstAction + "\n")

        return output

    def getStatistics(self):
        # Prime statistics arrays
        nodesAtLevel = []
        distinctNodeValuesAtLevel = []
        for level in range(0, 21):
            nodesAtLevel.append(0)
            distinctNodeValuesAtLevel.append([])

        # Walk the tree, updating statistics
        [nodesAtLevel, distinctNodeValuesAtLevel] = self._getStatistics(
            nodesAtLevel, distinctNodeValuesAtLevel
        )

        # Coalesce the sets of node values into counts
        distinctNodesAtLevel = []
        for level in range(0, 21):
            distinctNodesAtLevel.append(len(distinctNodeValuesAtLevel[level]))

        # Return the statistics:
        #    Count of nodes at each level
        #    Count of unique node values at each level
        return [nodesAtLevel, distinctNodesAtLevel]

    def _getStatistics(self, nodesAtLevel, distinctNodeValuesAtLevel):
        level = int(self.data["level"])
        if level > -1:
            # Increment count of nodes at this level
            nodesAtLevel[level] += 1

            # Add cell value to the list for this level - if it's not already in it
            cellValue = self.data["cell"]
            if cellValue not in distinctNodeValuesAtLevel[level]:
                distinctNodeValuesAtLevel[level].append(cellValue)

        for childNode in self.childNodes:
            [nodesAtLevel, distinctNodeValuesAtLevel] = childNode._getStatistics(
                nodesAtLevel, distinctNodeValuesAtLevel
            )

        return [nodesAtLevel, distinctNodeValuesAtLevel]

    def doHorizontalSpread(self, actionsList):
        self._doSpread("horizontal", actionsList)

    def doVerticalSpread(self, actionsList):
        self._doSpread("vertical", actionsList)

    def _doSpread(self, direction, actionsList):
        # Spread the level 0 nodes - either vertically or horizontally

        # Get the increment
        action = actionsList[0]
        if action.isdigit():
            increment = int(action)
        else:
            sys.stderr.write("Increment value is not a positive integer.\n")
            sys.exit()

        # Set iThoughtsSpread variables up
        if direction == "horizontal":
            iThoughtsSpread.resetHorizontalSpread(increment)
            iThoughtsSpread.resetVerticalSpread(0)
        else:
            iThoughtsSpread.resetHorizontalSpread(0)
            iThoughtsSpread.resetVerticalSpread(increment)

        for childNode in self.childNodes:
            childNode.data["position"] = (
                "{"
                + str(iThoughtsSpread.nextHorizontal())
                + ","
                + str(iThoughtsSpread.nextVertical())
                + "}"
            )

    def dump(self, actionsList=None) -> str:
        """
        >>> csv_tree = CSVTree("", "", "", "", "-1", "", "")
        >>> csv_child = CSVTree("", "square", "", "", "0", "", "Foo")
        >>> _ = csv_tree.addChild(csv_child)
        >>> print(csv_tree.dump([]).rstrip())
                                         -1
        square                           0                     Foo
        """
        s = "".join(
            f"{str(value)[:10]:<11}".replace("\n", "\\n")
            for value in self.data.values()
        )
        s = f"{'  ' * int(self.data['level'])}{s.rstrip()}" + "\n"
        return s + "".join(child.dump(actionsList) for child in self.getChildren())

    def dump2(self, treeLevel) -> str:
        s = (
            str(treeLevel)
            + " "
            + str(self.data["level"])
            + " "
            + self.data["cell"]
            + "\n"
        )
        return s + "".join(child.dump2(treeLevel + 1) for child in self.getChildren())

    def dumpAll(self):
        # Find root Node
        rootNode = self.parent
        while rootNode.parent is not None:
            rootNode = rootNode.parent

        # Dump from the root downwards
        return rootNode.dump2(-1)

    def makeAsBulletOfParent(self):
        if self.toBeDeleted:
            return

        # Acquire the parent
        if self.parent.data["level"] == -1:
            # Can't make this node a bullet under parent if parent is root i.e. level -1
            sys.stderr.write(f"Node {self.data['cell']} has no parent.\n")
        else:
            # Get parent cell value - to append to
            parentCellValue = self.parent.data["cell"]

            # Acquire this cell's value and add as a bullet to parent's cell value
            cellValue = self.data["cell"]
            newParentCellValue = parentCellValue + "\n" + "* " + cellValue

            # set parent's cell value to the newly augmented one
            self.parent.data["cell"] = newParentCellValue

            # Promote the nodes under this one, replacing it
            self.parent.replaceChild(self, self.childNodes)

    def sortKey(self, node):
        return node.data["cell"]

    def sortChildren(self):
        newChildren = self.childNodes.copy()
        newChildren.sort(reverse=False, key=self.sortKey)
        self.childNodes = newChildren

    def reverseChildren(self):
        newChildren = self.childNodes.copy()
        newChildren.reverse()
        self.childNodes = newChildren


def formatWhitespaceCharacters(whitespace):
    """
    >>> formatWhitespaceCharacters("a b \\t c d")
    '<tab><space><tab><space><tab><space><tab><space><tab>'
    """
    # return "".join("<space>" if c == " " else "<tab>" for c in whitespace)
    return "".join(
        "<space>" if c == " " else "<newline>" if c == "\n" else "<tab>"
        for c in whitespace
    )


def writeOutput(printLines):
    for line in printLines:
        print(line, file=sys.stderr)


if __name__ == "__main__":
    iThoughtsColours = iThoughtsColours()

    iThoughtsShapes = iThoughtsShapes()

    iThoughtsSpread = iThoughtsSpread()

    iThoughtsIcons = iThoughtsIcons()

    matchCriteria, actionsLists, output = ParameterParser().getParameters()

    writeOutput(output)

    #  Convert stdin data into CSV array - in whatever form it was
    (
        csvRows,
        colourColumn,
        levelColumn,
        noteColumn,
        shapeColumn,
        positionColumn,
        iconsColumn,
        progressColumn,
        priorityColumn,
        output,
    ) = TreeReader().createCSVArray()

    writeOutput(output)

    # Build the tree from the CSV array
    currentLevel = -1
    csvTree = CSVTree("", "", "", "", "", "", currentLevel, "", "")
    currentNode = csvTree

    for rowNumber, row in enumerate(csvRows[1:]):
        # Extract information from this row
        level = int(row[levelColumn])
        shape = row[shapeColumn]
        colour = row[colourColumn]
        note = row[noteColumn]
        position = row[positionColumn]
        icons = row[iconsColumn]
        progress = row[progressColumn]
        priority = row[priorityColumn]

        cellValue = row[levelColumn + level + 1]

        if level > currentLevel:
            # New child of previous node
            currentLevel = level
            currentNode = currentNode.addChild(
                CSVTree(
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )
        elif level == currentLevel:
            # New sibling of previous node
            currentNode = currentNode.parent.addChild(
                CSVTree(
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )
        else:
            # Not a sibling or child of previous node
            currentLevel = level

            # Look for the true parent by backing up the tree
            parentNode = currentNode
            while int(parentNode.data["level"]) >= int(level):
                parentNode = parentNode.parent

            # Add the new node - now we've found the parent to add it to
            currentNode = parentNode.addChild(
                CSVTree(
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )

        currentNode.data["row"] = row

    # Apply battery of parameter pairs to do the colouring etc.
    # (A row could match more than one and a later one overrides an earlier one)
    # In some cases the "match criterion" is a command and the "actions list"
    # contains parameters for that command. e.g. "markdown"
    for parmPair, matchCriterion in enumerate(matchCriteria):
        actionsList = actionsLists[parmPair]
        if (isinstance(matchCriterion, str)) and (matchCriterion.startswith("@")):
            csvTree.applyActions(matchCriterion, actionsList)
        elif matchCriterion.pattern.lower() == "dump":
            sys.stderr.write(csvTree.dump(actionsList))
        elif actionsList[0] == "keep":
            csvTree.processKeep(matchCriterion)
        else:
            func = {
                "check": csvTree.checkHierarchy,
                "digraph": csvTree.exportToDotDigraph,
                "hspread": csvTree.doHorizontalSpread,
                "html": csvTree.exportToHTML,
                "markdown": csvTree.exportToMarkdown,
                "promote": csvTree.promoteLevel,
                "stats": csvTree.writeStatistics,
                "vspread": csvTree.doVerticalSpread,
                "xml": csvTree.exportToXML,
            }.get(matchCriterion.pattern.lower())
            if func:
                output = func(actionsList)
                if output:
                    print("\n".join(output))
                    sys.exit()
                # commands that generate no output fall through
            else:
                csvTree.applyActions(matchCriterion, actionsList)

                # It's possible some nodes were deleted so actually remove them
                csvTree.cleanUpDeleted()

                csvTree.repairSubtreeLevels(-2)

    TreeWriter().writeTreeAsCSV()
