#!/usr/bin/env python3
"""
filterCSV - Augments matching CSV files - according to iThoughts requirements

It can set colours for nodes, change their shape, or delete them - if the node
matches any one of a set of criteria the user specifies.

Reads from stdin
Writes to stdout
Commentary to stderr


Command line parameters are pairs of:

1) A specifier. This is a regular expression to match. (A special value 'all' matches
    any value)
2) An action or sequence of actions.

Actions can be:

* A 1 or 2 digit colour number - relative to the top left of iThoughts' colour palette.
* A colour RGB hexadecimal value.  Ex. FFFFFF is black, 000000 is white, FF0000 is red
* 'delete'.
* A shape - as named by iThoughts.
"""

import csv
import re
import sys
import os
from collections import Counter
from string import hexdigits
import xml.etree.ElementTree as ElementTree
from datetime import datetime
from functools import reduce

# from CSVTree import CSVTree

filterCSV_level = "2.0+"
filterCSV_date = "1 May, 2022"

inputIndentCharacters = ""


class streamHandler:
    def streamIsAvailable(self, streamNumber):
        try:
            os.stat(streamNumber)
            return True
        except:
            return False


class ParameterParser:
    def preprocessCriterion(self, matchCriterion):
        if matchCriterion == "all":
            # This regex is guaranteed to match anything
            return re.compile(".*")
        elif matchCriterion == "none":
            # This regex is guaranteed to match nothing - and to fail quickly
            return re.compile("a^")
        elif matchCriterion.startswith("@"):
            # Pass through a level match criterion
            return matchCriterion
        else:
            # Some other criterion
            return re.compile(matchCriterion)

    def getParameters(self):
        matchCriteria = []
        actionsLists = []

        output = []

        output.append("\nfilterCSV " + filterCSV_level + " (" + filterCSV_date + ")\n")

        # figure out whether parameters are on command line or in a file
        useParameterFile = streamHandler.streamIsAvailable(3)
        if useParameterFile:
            output.append("Reading parameters from stream 3.\n")
            commandFile = open(3, "r")
            commands = commandFile.readlines()
        else:
            output.append("Reading parameters as command line arguments.\n")

        # Heading for parameters display
        output.append("Criterion".ljust(40, " ") + " Actions")
        output.append("---------".ljust(40, " ") + " -------")

        # Read in pairs of parameters from command line or file
        parmPairs = []

        if useParameterFile:
            # Use parameter file
            for parmLine in commands:
                # Process a line as a criterion / actions pair

                splitAtComment = parmLine.rstrip().split("//", 1)
                substantialLine = splitAtComment[0]
                if substantialLine != "":
                    parmPair = substantialLine.split(" ", 1)

                    matchCriterion = parmPair[0]
                    if matchCriterion[0:1] == "'":
                        matchCriterion = matchCriterion[1:]
                    if matchCriterion[-1] == "'":
                        matchCriterion = matchCriterion[:-1]

                    actionsString = parmPair[1].rstrip()
                    if actionsString[0:1] == "'":
                        actionsString = actionsString[1:]
                    if actionsString[-1] == "'":
                        actionsString = actionsString[:-1]
                    actionsString = actionsString.replace(" ", ",")

                    parmPair = [matchCriterion, actionsString]
                    parmPairs.append(parmPair)

        else:
            # Use command line parameters
            parmNumber = 1
            for parmPair in range((len(sys.argv) - 1) // 2):
                matchCriterion = sys.argv[parmNumber]
                actionsString = sys.argv[parmNumber + 1].lower().replace(" ", ",")

                parmPairs.append([matchCriterion, actionsString])
                parmNumber += 2

        for parmPair in parmPairs:
            # Handle match criterion
            matchCriterion = parmPair[0]
            matchCriteria.append(self.preprocessCriterion(matchCriterion))

            # Handle the actions that go with this match criterion
            actionsString = parmPair[1]
            actionList = actionsString.split(",")

            # For nextcolour/samecolour and nextshape/sameshape etc rewrite action as
            # the colour number or shape
            for actionNumber in range(len(actionList)):
                action = actionList[actionNumber]
                if action in ("nextcolour", "nextcolor", "nc"):
                    actionList[actionNumber] = str(
                        iThoughtsColours.getNextColourNumber()
                    )
                elif action in ("samecolour", "samecolor", "sc"):
                    actionList[actionNumber] = str(
                        iThoughtsColours.getSameColourNumber()
                    )
                elif action in ("nextshape", "ns"):
                    actionList[actionNumber] = iThoughtsShapes[
                        iThoughtsShapes.getNextShapeNumber()
                    ]
                elif action in ("sameshape", "ss"):
                    actionList[actionNumber] = iThoughtsShapes[
                        iThoughtsShapes.getSameShapeNumber()
                    ]

            # Add actions list to list of actions lists
            actionsLists.append(actionList)

            output.append(matchCriterion.ljust(40, " ") + " " + actionsString)

        output.append("\n")

        return matchCriteria, actionsLists, output


class TreeReader:
    def detectInputStreamType(self, inputFile):
        firstLine = inputFile[0]
        firstChar = firstLine[0]

        if firstLine.lower().find("level0") > -1:
            return "iThoughtsCSV"
        else:
            if firstLine.find(",") > -1:
                return "CSV"
            elif firstChar == "<":
                return "XML"
            elif (firstChar in ["#", "*", "-"]) or (firstLine.find(":") > -1):
                return "markdown"
            else:
                return "text"

    @staticmethod
    def injectColumn(CSVArray, columnName):
        # Injects the named column at the beginning of each line,
        # with the heading given by columnName
        for rowNumber, _ in enumerate(CSVArray):
            if rowNumber == 0:
                CSVArray[0].insert(0, columnName)
            else:
                CSVArray[rowNumber].insert(0, "")
        return CSVArray

    def ensureMandatoryColumns(self, csvRows):
        """
        Add columns if they are not already present
        """
        for (
            column
        ) in "dueDate startDate effort(hours) priority progress icons shape position note colour".split():
            if column not in csvRows[0]:
                csvRows = self.injectColumn(csvRows, column)

        # Return the rows and the position of each column
        return (
            csvRows,
            csvRows[0].index("colour"),
            csvRows[0].index("level"),
            csvRows[0].index("note"),
            csvRows[0].index("shape"),
            csvRows[0].index("position"),
            csvRows[0].index("icons"),
            csvRows[0].index("progress"),
            csvRows[0].index("priority"),
            csvRows[0].index("effort(hours)"),
            csvRows[0].index("startDate"),
            csvRows[0].index("dueDate"),
        )

    def ensureColumnsPopulated(self, csvRows):
        # Ensures every column in the header row is present in each subsequent row
        minimumColumnCount = len(csvRows[0])
        for rowNumber, row in enumerate(csvRows):
            extraCells = minimumColumnCount - len(row)
            if extraCells > 0:
                csvRows[rowNumber] += [""] * extraCells

        return csvRows

    def readiThoughtsCSVTree(self, inputFile):
        output = []
        # Build a list of rows
        csvRows = [row for row in csv.reader(inputFile)]
        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readNormalCSVTree(self, inputFile):
        output = []

        # Build a list of rows
        csvRows = []
        noteCells = []
        for row in csv.reader(inputFile):
            csvRows.append(row)
            # See if there's another non-blank cell in the row
            nonBlankCells = 0
            lastNonBlankCell = 0
            cellNumber = 0
            for cell in row:
                if cell != "":
                    nonBlankCells += 1
                    lastNonBlankCell = cellNumber
                cellNumber += 1

            # If there's another non-blank cell last such becomes a note
            if nonBlankCells > 1:
                noteCells.append(row[lastNonBlankCell])
            else:
                noteCells.append("")

        # Add a header line
        csvRows.insert(
            0,
            [
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        # Add level column to each row
        rowNumber = 0
        for row in csvRows:
            if rowNumber > 0:
                cellNumber = 0
                for cell in row:
                    if cell != "":
                        break
                    cellNumber += 1
                row.insert(0, cellNumber)
            rowNumber += 1

        # Inject any notes (last blank cell)
        csvRows = self.injectColumn(csvRows, "note")
        noteColumn = csvRows[0].index("note")

        rowNumber = 0
        for row in csvRows:
            if rowNumber > 0:
                row[noteColumn] = noteCells[rowNumber - 1]
            rowNumber += 1

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readMarkdownOrTextTree(self, inputFileWithPossibleMetadata):
        global inputIndentCharacters

        output = []

        inputFile = []

        metadata = {}

        # See if there's a blank line to terminate Metadata
        lineNumber = 0
        firstBlankLineAt = -1
        for line in inputFileWithPossibleMetadata:
            if line == "\n":
                firstBlankLineAt = lineNumber
                break
            lineNumber += 1

        if firstBlankLineAt == -1:
            # There is no Metadata
            for line in inputFileWithPossibleMetadata:
                inputFile.append(line)
        else:
            # Check everything before the blank line contains at least 1 colon
            hasMetadata = True
            lineNumber = 0
            for line in inputFileWithPossibleMetadata:
                if lineNumber >= firstBlankLineAt:
                    break
                if line.find(":") == -1:
                    hasMetadata = False
                lineNumber += 1
            if hasMetadata:
                # Is metadata so keep everything after the blank line

                output.append("\nMetadata\n--------")

                lineNumber = 0
                for line in inputFileWithPossibleMetadata:
                    if lineNumber > firstBlankLineAt:
                        inputFile.append(line)
                    elif lineNumber < firstBlankLineAt:
                        splitLine = line.split(":", 1)
                        metadataKey = splitLine[0]
                        metadataValue = splitLine[1].strip()
                        output.append(metadataKey + " -->" + metadataValue)
                        metadata[metadataKey] = metadataValue
                    lineNumber += 1
                output.append("")
            else:
                # Is not metadata so keep the whole file
                for line in inputFileWithPossibleMetadata:
                    inputFile.append(line)

        maxHeadingLevel = -1
        # Detect heading levels
        headingLevels = [False, False, False, False, False, False]
        for line in inputFile:
            if line.startswith("# "):
                maxHeadingLevel = max(maxHeadingLevel, 0)
                headingLevels[0] = True
            elif line.startswith("## "):
                maxHeadingLevel = max(maxHeadingLevel, 1)
                headingLevels[1] = True
            elif line.startswith("### "):
                maxHeadingLevel = max(maxHeadingLevel, 2)
                headingLevels[2] = True
            elif line.startswith("#### "):
                maxHeadingLevel = max(maxHeadingLevel, 3)
                headingLevels[3] = True
            elif line.startswith("##### "):
                maxHeadingLevel = max(maxHeadingLevel, 4)
                headingLevels[4] = True
            elif line.startswith("###### "):
                maxHeadingLevel = max(maxHeadingLevel, 5)
                headingLevels[5] = True

        headingLevelCount = 0
        headingLevelString = ""
        for h in range(6):
            if headingLevels[h]:
                headingLevelString += " " + str(h + 1)
                headingLevelCount += 1

        output.append("Heading levels detected: " + headingLevelString + "\n")

        # Build array of rows
        csvRows = []

        # Work out what an indent would be - in numbers of characters per level,
        # using the first indented line as the template.
        indentLength = 0
        for line in inputFile:
            if line == "\n":
                continue
            indentLength = len(line) - len(line.lstrip())
            if indentLength > 0:
                # This is the first line with whitespace at the beginning

                # Save the indentation whitespace
                indentCharacters = line[0:indentLength]
                inputIndentCharacters = indentCharacters

                # Print the detected indentation - so user can debug
                output.append(
                    "Indentation detected: "
                    + formatWhitespaceCharacters(indentCharacters)
                )

                break

        # Insert a header row, with attribute columns and a level0 column plus other
        # levels
        csvRows.append(
            [
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        # Add a level column if one is not already present, and move the text into the
        # right level - for each data line
        for lineNumber, line in enumerate(inputFile):
            # Remove any blank lines
            if line == "\n":
                continue

            # A data line so work out how many levels deep it is indented
            if indentLength > 0:
                lineIndentLength = len(line) - len(line.lstrip())
                if lineIndentLength % indentLength > 0:
                    if lineIndentLength == 1:
                        output.append("Bad indentation: 1 white space character.")
                    else:
                        output.append(
                            "Bad indentation:"
                            + str(lineIndentLength)
                            + " white space characters."
                        )

                    output.append(
                        "Should be multiple of "
                        + str(indentLength)
                        + ". Rounding level down to "
                        + str(lineIndentLength / indentLength)
                        + "."
                    )
                    output.append("Line in error (" + str(lineNumber) + ") is: " + line)
                    output.append(
                        "Leading white space characters: "
                        + formatWhitespaceCharacters(line[0:lineIndentLength])
                    )
                else:
                    lineIndentCharacters = line[0:lineIndentLength]
                    if lineIndentCharacters != indentCharacters * (
                        lineIndentLength // indentLength
                    ):
                        output.append("Bad indentation characters:")
                        output.append(
                            "Line in error (" + str(lineNumber) + ") is: " + line
                        )
                        output.append(
                            "Leading white space characters: "
                            + formatWhitespaceCharacters(lineIndentCharacters)
                        )

            newRow = []

            if line.startswith("# "):
                level = 0
            elif line.startswith("## "):
                level = 1
            elif line.startswith("### "):
                level = 2
            elif line.startswith("#### "):
                level = 3
            elif line.startswith("##### "):
                level = 4
            elif indentLength == 0:
                level = maxHeadingLevel + 1
            else:
                level = maxHeadingLevel + 1 + (lineIndentLength // indentLength)

            newRow.append(str(level))

            # Insert blank cells - according to level
            for lev in range(level):
                newRow.append("")

            # Clean the line text to remove any list item marker or heading text
            cleanedLine = line.lstrip().rstrip()
            if cleanedLine[0:2] == "# ":
                cleanedLine = cleanedLine[2:]
            if cleanedLine[0:3] == "## ":
                cleanedLine = cleanedLine[3:]
            if cleanedLine[0:4] == "### ":
                cleanedLine = cleanedLine[4:]
            if cleanedLine[0:5] == "#### ":
                cleanedLine = cleanedLine[5:]
            if cleanedLine[0:6] == "##### ":
                cleanedLine = cleanedLine[6:]
            if cleanedLine[0:7] == "###### ":
                cleanedLine = cleanedLine[7:]
            elif cleanedLine[0:2] in ["* ", "- "]:
                cleanedLine = cleanedLine[2:]

            # Add the cleaned line at the appropriate level
            newRow.append(cleanedLine)

            # Add this new row
            csvRows.append(newRow)

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def readOPMLTree(self, tree):
        self.XMLNamespaces = {}

        output = ["XML is specifically 'OPML'.\n"]

        if tree[0].tag == "head":
            # Level 0 node will be the contents of the title element within the
            # head element
            titleText = tree[0][0].text.strip()
            haveHead = True

            if (len(tree) > 1) & (tree[1].tag == "body"):
                haveBody = True
                bodyElement = tree[1]
            else:
                haveBody = False
        else:
            haveHead = False

            if tree[0].tag == "body":
                haveBody = True
                bodyElement = tree[0]
            else:
                haveBody = False

        # Build array of rows
        csvRows = []

        # Insert a header row, with attribute columns and a level0 column plus other
        # levels
        csvRows.append(
            [
                "dueDate",
                "startDate",
                "effort(hours)",
                "priority",
                "progress",
                "icons",
                "position",
                "colour",
                "shape",
                "level",
                "level0",
                "level1",
                "level2",
                "level3",
                "level4",
                "level5",
                "level6",
                "level7",
                "level8",
                "level9",
                "level10",
                "level11",
                "level12",
                "level13",
                "level14",
                "level15",
                "level16",
                "level17",
                "level18",
                "level19",
                "level20",
            ],
        )

        if haveHead:
            headCSVRow = ["", "", "", "", "", "", "", "", "", "0", titleText]

            csvRows.append(headCSVRow)

            if haveBody:
                # Any level 1+ elements are children of the body element
                for child in bodyElement:
                    csvRows += self._readOPMLTree(child, 1)
            else:
                # All top-level children of tree, except head, are level 1
                for child in tree:
                    if child.tag != "head":
                        csvRows += self._readOPMLTree(child, 1)
        else:
            # Don't have a head row so have to look for body or top-level outline
            # elements
            if haveBody:
                # All top-level children of body element are level 0
                for child in bodyElement:
                    csvRows += self._readOPMLTree(child, 0)
            else:
                # All top-level children of tree are level 0
                for child in tree:
                    csvRows += self._readOPMLTree(child, 0)

        return self.ensureMandatoryColumns(csvRows) + (output,)

    def _readOPMLTree(self, XMLNode, level):
        csvRows = []
        nodeText = XMLNode.attrib["text"]

        nodeRow = ["", "", "", "", "", "", "", "", "", str(level)]

        levelBlankCells = [""] * (level)
        nodeRow += levelBlankCells

        nodeRow.append(nodeText)
        csvRows.append(nodeRow)

        for child in XMLNode:
            csvRows += self._readOPMLTree(child, level + 1)

        return csvRows

    def readXMLTree(self, inputFile):
        output = []

        # Prepare the input text for namespace parsing and XML parsing
        XMLText = "\n".join(inputFile)

        # Create the XML parse tree
        self.XMLTree = ElementTree.fromstring(XMLText)

        # Check if OPML
        if self.XMLTree.tag == "opml":
            # Is OPML so treat separately from other XML
            return self.readOPMLTree(self.XMLTree)
        else:
            # Is not OPML
            # Hunt for the default namespace
            split1 = XMLText.split('xmlns="')
            if len(split1) == 1:
                output.append("No default namespace specification.")
                self.defaultXMLNamespace = ""
            else:
                self.defaultXMLNamespace = split1[1].split('"')[0]
                output.append(f"Default namespace is '{self.defaultXMLNamespace}'")

            # Hunt for other namespaces
            self.XMLNamespaces = {}
            split3 = XMLText.split("xmlns:")
            for fragment in range(len(split3)):
                if fragment > 0:
                    split4 = split3[fragment].split('="')
                    key = split4[0]
                    split5 = split4[1].split('"')
                    value = split5[0]
                    self.XMLNamespaces[key] = value

            # Build array of rows
            csvRows = []

            # Insert a header row, with attribute columns and a level0 column plus other
            # levels
            csvRows.append(
                [
                    "dueDate",
                    "startDate",
                    "effort(hours)",
                    "priority",
                    "progress",
                    "icons",
                    "position",
                    "colour",
                    "shape",
                    "level",
                    "level0",
                    "level1",
                    "level2",
                    "level3",
                    "level4",
                    "level5",
                    "level6",
                    "level7",
                    "level8",
                    "level9",
                    "level10",
                    "level11",
                    "level12",
                    "level13",
                    "level14",
                    "level15",
                    "level16",
                    "level17",
                    "level18",
                    "level19",
                    "level20",
                ],
            )

            csvRows += self._readXMLTree(self.XMLTree, 0)

            return self.ensureMandatoryColumns(csvRows) + (output,)

    def resolveNamespaces(self, textToEdit):
        editedText = textToEdit.replace("{" + self.defaultXMLNamespace + "}", "")
        for key in self.XMLNamespaces:
            editedText = editedText.replace(
                "{" + self.XMLNamespaces[key] + "}", key + ":"
            )
        return editedText

    def _readXMLTree(self, XMLNode, level):
        csvRows = []

        # Edit the element tag - in case of namespaces
        editedElementName = self.resolveNamespaces(XMLNode.tag)

        # Create beginning of the row for the node itself - without attributes

        if XMLNode is self.XMLTree:
            # Is root node so create legend rows before it
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "{-300,-120}",
                    iThoughtsColours.getColour(2),
                    "rectangle",
                    "0",
                    "element",
                ]
            )
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "{-300,-85}",
                    iThoughtsColours.getColour(8),
                    "rectangle",
                    "0",
                    "value",
                ]
            )
            csvRows.append(
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "{-300,-50}",
                    iThoughtsColours.getColour(6),
                    "rectangle",
                    "0",
                    "attribute",
                ]
            )

            # Set position of root node to {0,0}
            elementCSVRow = [
                "",
                "",
                "",
                "",
                "",
                "",
                "{0,0}",
                iThoughtsColours.getColour(2),
                "rounded",
                f"{str(level)}",
            ]
        else:
            # Set position to blank for all but the root node
            elementCSVRow = [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                iThoughtsColours.getColour(2),
                "rounded",
                f"{str(level)}",
            ]

        # Add blank cells to position the cell with the element in
        if level > 0:
            levelBlankCells = [""] * level
            elementCSVRow += levelBlankCells

        # Add the (edited) element name
        elementCSVRow.append(editedElementName)

        # Add the row to the list of rows
        csvRows.append(elementCSVRow)

        for key, value in XMLNode.attrib.items():
            attributeCSVRow = [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                iThoughtsColours.getColour(6),
                "rounded",
                f"{str(level + 1)}",
            ]
            levelBlankCells = [""] * (level + 1)
            attributeCSVRow += levelBlankCells

            editedAttributeName = self.resolveNamespaces(key)
            attributeCSVRow += [f'{editedAttributeName}="{value}"']
            csvRows.append(attributeCSVRow)
        if XMLNode.text is not None:
            if XMLNode.text.lstrip().rstrip() != "":
                textCSVRow = [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    iThoughtsColours.getColour(8),
                    "rounded",
                    f"{str(level + 1)}",
                ]
                levelBlankCells = [""] * (level + 1)
                textCSVRow += levelBlankCells
                textCSVRow += [f"{XMLNode.text}"]
                csvRows.append(textCSVRow)

        for child in XMLNode:
            csvRows += self._readXMLTree(child, level + 1)

        return csvRows

    def createCSVArray(self):
        output = []

        # Read in whatever's in stdin - which might not be CSV
        inputFile = sys.stdin.readlines()

        # Detect the input stream type
        inputType = self.detectInputStreamType(inputFile)

        output.append(f"Input type detected as '{inputType}'.\n")

        # Depending on detected input type create a create CSV-like array,
        # including mandatory columns
        if inputType == "iThoughtsCSV":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output1,
            ) = self.readiThoughtsCSVTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output,
            )
        elif inputType == "CSV":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output1,
            ) = self.readNormalCSVTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output,
            )
        elif inputType in ["markdown", "text"]:
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output1,
            ) = self.readMarkdownOrTextTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output,
            )
        elif inputType == "XML":
            (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output1,
            ) = self.readXMLTree(inputFile)

            output += output1

            csvRows = self.ensureColumnsPopulated(csvRows)
            if len(self.XMLNamespaces) > 0:
                output.append("Namespace".ljust(20, " ") + " Namespace URL")
                output.append("---------".ljust(20, " ") + " -------------")
                for key in self.XMLNamespaces:
                    output.append(key.ljust(20, " ") + " " + self.XMLNamespaces[key])
                output.append("")

            return (
                csvRows,
                colourColumn,
                levelColumn,
                noteColumn,
                shapeColumn,
                positionColumn,
                iconsColumn,
                progressColumn,
                priorityColumn,
                effortColumn,
                startColumn,
                dueColumn,
                output,
            )


class TreeWriter:
    def writeTreeAsCSV(self):
        # Write the tree out as a CSV file in iThoughts format
        CSVwriter = csv.writer(sys.stdout, quoting=csv.QUOTE_ALL)

        # Write the header row
        headerRow = [
            "dueDate",
            "startDate",
            "effort(hours)",
            "priority",
            "progress",
            "icons",
            "colour",
            "note",
            "position",
            "shape",
            "level",
        ]

        # Establish how many levels to put out in the heading
        levels = csvTree.calculateMaximumLevel() + 1

        for level in range(levels):
            headerRow.append("level" + str(level))

        CSVwriter.writerow(headerRow)

        # Write out the resulting CSV data
        outputArray = []
        outputArray = csvTree.writeCSVTree(outputArray)

        for row in outputArray:
            CSVwriter.writerow(row)


class iThoughtsColours:
    light_pastel = """FFB2B2 FFD8B2 FFFFB2 D8FFB2 B2FFB2 B2FFD8
                      B2FFFF B2D8FF B2B2FF D8B2FF FFB2FF FFB2D8""".split()

    dark_pastel = """B24747 B27C47 B2B247 7CB247 47B247 47B27C
                     47B2B2 477CB2 4747B2 7C47B2 B247B2 B2477C""".split()

    saturated = """FF0000 FF7F00 FFFF00 7FFF00 00FF00 00FF7F
                   00FFFF 007FFF 0000FF 7F00FF FF00FF FF007F""".split()

    grayscale = """000000 929292 a9a9a9 C0C0C0 D6D6D6 FFFFFF""".split()

    solarized = """002b36 073642 586e75 657b83 839496 93a1a1
                   eee8d5 fdf6e3 b58900 cb4b16 dc322f d33682
                   6c71c4 268bd2 2aa198 859900""".split()
    colours = light_pastel + dark_pastel + saturated + grayscale + solarized

    colourNumber = 0

    def __getitem__(self, key):
        """
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours[0]
        'FFB2B2'
        >>> ithoughts_colours[-1]
        '859900'
        """
        return self.colours[key]

    def getColour(self, colourNumber):
        """Get colour based on colour number (which starts at 1)
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getColour(1)
        'FFB2B2'
        >>> ithoughts_colours.getColour(58)
        '859900'
        """
        return self[colourNumber - 1]

    def __len__(self):
        """
        >>> len(iThoughtsColours())
        58
        """
        return len(self.colours)

    def getNextColourNumber(self):
        """Get the next colour number from the iThoughts palette
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getNextColourNumber()
        1
        """
        self.colourNumber += 1
        return self.colourNumber

    def getSameColourNumber(self):
        """Get the same colour number from the iThoughts palette
        >>> ithoughts_colours = iThoughtsColours()
        >>> ithoughts_colours.getSameColourNumber()
        0
        """
        return self.colourNumber


class iThoughtsShapes:
    # Shapes as understood by iThoughts
    shapes = (
        "auto",
        "rectangle",
        "square",
        "rounded",
        "pill",
        "parallelogram",
        "diamond",
        "triangle",
        "oval",
        "circle",
        "underline",
        "none",
        "square bracket",
        "curved bracket",
    )

    shapeNumber = 0

    def __contains__(self, item):
        """Is item in self.shapes
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> all(shape in ithoughts_shapes for shape
        ...     in ('auto', 'triangle', 'none', 'curved bracket'))
        True
        """
        return item in self.shapes

    def __getitem__(self, key):
        """Get shape based on shape number (which starts at 0)
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes[0]
        'auto'
        >>> ithoughts_shapes[-1]
        'curved bracket'
        """
        return self.shapes[key]

    def __len__(self):
        """
        >>> len(iThoughtsShapes())
        14
        """
        return len(self.shapes)

    def getNextShapeNumber(self):
        """Get the next shape number from the iThoughts list
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes.getNextShapeNumber()
        1
        """
        self.shapeNumber += 1
        return self.shapeNumber

    def getSameShapeNumber(self):
        """Get the same shape number from the iThoughts list
        >>> ithoughts_shapes = iThoughtsShapes()
        >>> ithoughts_shapes.getSameShapeNumber()
        0
        """
        return self.shapeNumber


class iThoughtsIcons:
    # icons as understood by iThoughts
    icons = (
        "tick",
        "tickbox",
        "p0",
        "p1",
        "p2",
        "p3",
        "p4",
        "p5",
        "p6",
        "p7",
        "p8",
        "p9",
        "signal-flag-red",
        "signal-flag-yellow",
        "signal-flag-green",
        "icon-signal-flag-black",
        "icon-signal-flag-blue",
        "icon-signal-flag-orange",
        "icon-signal-flag-purple",
        "icon-signal-flag-white",
        "icon-signal-flag-checkered",
        "icon-hat-black",
        "icon-hat-blue",
        "icon-hat-green",
        "icon-hat-red",
        "icon-hat-white",
        "icon-hat-yellow",
        "icon-calendar1",
        "icon-calendar7",
        "icon-calendar12",
        "icon-calendar31",
        "icon-calendar52",
        "arrow-down-blue",
        "arrow-left-blue",
        "arrow-right-blue",
        "arrow-up-blue",
        "arrow-up-green",
        "arrow-down-red",
        "stop",
        "prep",
        "go",
        "smiley_happy",
        "icon-smiley-neutral",
        "smiley_sad",
        "icon-money",
        "currency-dollar",
        "currency-euro",
        "currency-pound",
        "currency-yen",
        "icon-currency-won",
        "icon-currency-yuan",
        "hand-yellow-card",
        "hand-red-card",
        "hand-stop",
        "hand-thumb-down",
        "hand-thumb-up",
        "question",
        "icon-questionmark",
        "icon-information",
        "icon-exclamationmark",
        "alert",
        "icon-add",
        "cross",
        "sign-forbidden",
        "sign-stop",
        "idea",
        "icon-camera",
        "auction-hammer",
        "bell",
        "bomb",
        "dynamite",
        "fire",
        "hourglass",
        "target",
        "view",
        "icon-airplane",
        "icon-alarmclock",
        "icon-bug",
        "icon-businessmen",
        "icon-car",
        "icon-clients",
        "icon-cup",
        "icon-data",
        "icon-desktop",
        "icon-earth",
        "icon-flash",
        "icon-gear",
        "icon-heart",
        "icon-key",
        "icon-lock-open",
        "icon-lock",
        "icon-mail",
        "icon-pin",
        "icon-printer",
        "icon-scales",
        "icon-star",
        "icom-telephone",
        "icon-pencil",
        "icon-alarm",
        "icon-book",
        "icon-certificate",
        "icon-cloud",
        "icon-compasses",
        "icon-dice",
        "icon-folder",
        "icon-document",
        "icon-male",
        "icon-female",
        "icon-newspaper",
        "icon-paperclip",
        "icon-presentation",
        "icon-signpost",
        "icon-step",
    )

    def __contains__(self, item):
        return item in self.icons


class iThoughtsSpread:
    horizontalPosition = 0
    horizontalIncrement = 0
    verticalPosition = 0
    verticalIncrement = 0

    def resetHorizontalSpread(self, horizontalIncrement):
        self.horizontalPosition = 0
        self.horizontalIncrement = horizontalIncrement

    def nextHorizontal(self):
        x = self.horizontalPosition
        self.horizontalPosition += self.horizontalIncrement
        return x

    def resetVerticalSpread(self, verticalIncrement):
        self.verticalPosition = 0
        self.verticalIncrement = verticalIncrement

    def nextVertical(self):
        y = self.verticalPosition
        self.verticalPosition += self.verticalIncrement
        return y

    def getNextPosition(self):
        return self.nextHorizontal(), self.nextVertical()


class CSVTree:
    def __init__(
        self,
        dueDate,
        startDate,
        effort,
        priority,
        progress,
        icons,
        shape,
        colour,
        note,
        level,
        position,
        cell,
    ):
        """
        >>> csv_tree = CSVTree("startDate", "dueDate", "effort(hours)", "priority", "progress", "icons","shape", "colour", "note", "level", 1, "cell")
        >>> csv_tree.data["shape"]
        'shape'
        """
        self.toBeDeleted = False
        self.childNodes = []

        if dueDate == "":
            parsedDueDate = None
        else:
            parsedDueDate = datetime.strptime(dueDate, "%Y-%m-%dT%H:%M:%S%z")

        if startDate == "":
            parsedStartDate = None
        else:
            parsedStartDate = datetime.strptime(startDate, "%Y-%m-%dT%H:%M:%S%z")

        if effort == "":
            parsedEffortHours = None
        else:
            parsedEffortHours = float(effort)

        self.data = {
            "dueDate": parsedDueDate,
            "startDate": parsedStartDate,
            "effort(hours)": parsedEffortHours,
            "priority": priority,
            "progress": progress,
            "icons": icons,
            "shape": shape,
            "colour": colour,
            "note": note,
            "level": level,
            "position": position,
            "cell": cell,
        }
        self.parent = None
        self.matched = False
        self.matches = 0

    def addChild(self, childNode):
        self.childNodes.append(childNode)
        childNode.parent = self
        return childNode

    def deleteChild(self, childNode):
        self.childNodes.remove(childNode)

    def cleanUpDeleted(self):
        # Actually remove nodes marked for deletion
        # Propagate to children in reverse order - for tree traversal to work
        for c in range(len(self.childNodes) - 1, -1, -1):
            self.childNodes[c].cleanUpDeleted()

        # Now remove this node - if to be deleted
        if self.toBeDeleted:
            self.parent.deleteChild(self)

    def getChildren(self):
        return self.childNodes

    def replaceChild(self, childNode, replacementChildren):
        # Remove the child node having replaced it with the replacement
        # children, which are a list. (List could contain 1 item, of course.)
        if childNode in self.childNodes:
            # Child node is indeed a child so find its index
            childIndex = self.childNodes.index(childNode)

            # Insert each item from the replacement list before the child
            for i in range(len(replacementChildren)):
                self.childNodes.insert(i + childIndex - 1, replacementChildren[i])

            # Mark the node that's been replaced to be deleted
            childNode.toBeDeleted = True

            # Fix up the tree levels - from root downwards
            # self.repairSubtreeLevels(int(self.data["level"])-1)
        else:
            # Supposed child node isn't a child of this CSVTree object
            sys.stderr.write(
                childNode.data["cell"]
                + " is not a child of "
                + self.data["cell"]
                + "\n"
            )

    def isMatch(self, criterion):
        """
        Common method for establishing if a node matches some criterion, usually a regex
        """
        return (
            (re.search(criterion, self.data["icons"]) is not None)
            | (re.search(criterion, self.data["shape"]) is not None)
            | (re.search(criterion, self.data["colour"]) is not None)
            | (re.search(criterion, self.data["note"]) is not None)
            | (re.search(criterion, self.data["cell"]) is not None)
        )

    def applyAction(self, criterion, action, propagateToChildren):
        if action == "delete":
            # Mark the node for deletion
            self.toBeDeleted = True

            # Don't propagate
            propagateToChildren = False

        elif action == "asbullet":
            self.makeAsBulletOfParent()

        elif action == "reverse":
            self.reverseChildren()

        elif action == "sort":
            self.sortChildren()

        elif action[0] == "{":
            # position specified
            self.data["position"] = action

            # Don't propagate
            propagateToChildren = False

        elif action == "note":
            # Document the match in the note field
            if isinstance(criterion, str):
                criterionString = criterion
            else:
                criterionString = criterion.pattern

            if self.data["note"] != "":
                self.data["note"] += "\nMatched " + criterionString
            else:
                self.data["note"] = "Matched " + criterionString

        elif action == "noshape":
            # Remove any shape specification from the matched node
            self.data["shape"] = ""

        elif action == "nonote":
            # Remove any note specification from the matched node
            self.data["note"] = ""

        elif action == "noposition":
            # Remove any position specification from the matched node
            self.data["position"] = ""

        elif action == "nocolour":
            # Remove any colour specification from the matched node
            self.data["colour"] = ""

        elif len(action) == 6 and all(c in hexdigits for c in action):
            # 6-digit hexadecimal so is colour RGB value
            self.data["colour"] = action

        elif action in iThoughtsShapes:
            # Is a shape
            self.data["shape"] = action

        elif action[0:9] == "priority:":
            if action[9:].isdigit():
                self.data["priority"] = action[9:]
            else:
                sys.stderr.write(
                    f"Erroneous priority value {action[9:]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )

        elif action[0:5] == "prio:":
            if action[5].isdigit():
                self.data["priority"] = action[5]
            else:
                sys.stderr.write(
                    f"Erroneous priority value {action[5]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )

        elif action in ["noprio", "nopriority"]:
            self.data["priority"] = ""

        elif action[0:9] == "progress:":
            if action[9:].isdigit():
                self.data["progress"] = action[9:]
            else:
                sys.stderr.write(
                    f"Erroneous progress value {action[9:]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )

        elif action[0:5] == "prog:":
            if action[5].isdigit():
                self.data["progress"] = action[5]
            else:
                sys.stderr.write(
                    f"Erroneous progress value {action[5]} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )
        elif action in ["noprog", "noprogress"]:
            self.data["progress"] = ""

        elif action in iThoughtsIcons:
            # Is an icons
            if self.data["icons"] == "":
                self.data["icons"] = action
            else:
                self.data["icons"] += "," + action

        elif action == "noicons":
            self.data["icons"] = ""

        elif action[0:4] == "sub:":
            self.data["cell"] = re.sub(criterion, action[4:], self.data["cell"])
        elif action == "justcount":
            pass
            
        elif action.isdigit():
            # Attempt to parse as from the colour palette
            colourNumber = int(action)

            # We have an integer. If it is too big but not 6 digits
            # we flag an error and don't do the update
            if colourNumber > len(iThoughtsColours):
                sys.stderr.write(
                    f"Erroneous colour value {colourNumber} "
                    f"(Pattern was: '{criterion.pattern}')." + "\n"
                )

            else:
                self.data["colour"] = iThoughtsColours.getColour(colourNumber)

        else:
            sys.stderr.write(
                f"Erroneous action value {action} "
                f"(Pattern was: '{criterion.pattern}')." + "\n"
            )
        return propagateToChildren

    def applyActions(self, criterion, actionsList):
        """
        Apply filter to this node - if not tree root
        """
        
        matchCount = 0
        propagateToChildren = True
        if self.data["level"] != -1:
            # Test string-based criteria
            if isinstance(criterion, str):
                # Level criterion?
                if criterion.startswith("@level:"):
                    potentialLevelString = criterion[7:].rstrip()
                    if potentialLevelString.isdigit():
                        wantedLevel = int(potentialLevelString)
                        if int(self.data["level"]) == wantedLevel:
                            # We have a node at the right level
                            self.matched = True
                            matchCount += 1
                            
                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )
                    else:
                        # The level specified wasn't an integer
                        print(f"Bad level string '{potentialLevelString}")

                # Priority criterion?
                elif criterion.startswith("@priority:") | criterion.startswith(
                    "@prio:"
                ):
                    if criterion.startswith("@priority:"):
                        potentialPriorityString = criterion[10:].rstrip()
                    else:
                        potentialPriorityString = criterion[6:].rstrip()
                    if potentialPriorityString.isdigit():
                        wantedPriority = int(potentialPriorityString)
                        if self.data["priority"] == potentialPriorityString:
                            # We have a node with the right priority
                            self.matched = True
                            matchCount += 1

                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )

                # No priority criterion?
                elif criterion in ["@nopriority", "@noprio"]:
                    if self.data["priority"] == "":
                        # We have a node with no priority
                        self.matched = True
                        matchCount += 1
                        
                        for action in actionsList:
                            propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )

                # Progress criterion?
                elif criterion.startswith("@progress:") | criterion.startswith(
                    "@prog:"
                ):
                    if criterion.startswith("@progress:"):
                        potentialProgressString = criterion[10:].rstrip()
                    else:
                        potentialProgressString = criterion[6:].rstrip()
                    if potentialProgressString.isdigit():
                        wantedProgress = int(potentialProgressString)
                        if self.data["progress"] == potentialProgressString:
                            # We have a node with the right progress
                            self.matched = True
                            matchCount += 1

                            for action in actionsList:
                                propagateToChildren = self.applyAction(
                                    criterion, action, propagateToChildren
                                )

                # No progress criterion?
                elif criterion in ["@noprogress", "@noprog"]:
                    if self.data["progress"] == "":
                        # We have a node with no progress
                        self.matched = True
                        matchCount += 1
                        
                        for action in actionsList:
                            propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )

                # Shape criterion?
                elif criterion.startswith("@shape:"):
                    wantedShape = criterion[7:].rstrip()
                    if self.data["shape"] == wantedShape:
                        # We have a node with the right shape
                        self.matched = True
                        matchCount += 1

                        for action in actionsList:
                             propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )

                # No shape criterion?
                elif criterion == "@noshape":
                    if self.data["shape"] == "":
                        # We have a node with no shape
                        self.matched = True
                        matchCount += 1
                        
                        for action in actionsList:
                            propagateToChildren = self.applyAction(
                                criterion, action, propagateToChildren
                            )
                else:
                    # Criterion is a regular expression rather than a string
                    print(f"Bad criterion: '{criterion}'.")
                    
            elif self.isMatch(criterion):
                # Matched so apply all actions triggered by this match
                self.matched = True
                matchCount += 1
                
                for action in actionsList:
                    propagateToChildren = self.applyAction(
                        criterion, action, propagateToChildren
                    )

        # Apply filter to children, recursively - if propagation is indicated
        if propagateToChildren:
            for child in self.childNodes:
                matchCount += child.applyActions(criterion, actionsList)

        return matchCount

    def writeCSVTree(self, outputArray):
        # Compose this node's line - if not root node
        level = int(self.data["level"])
        if level > -1:
            line = []
            for (
                key
            ) in "dueDate startDate effort(hours) priority progress icons colour note position shape level".split():
                if key == "dueDate":
                    parsedDueDate = self.data["dueDate"]
                    if parsedDueDate == None:
                        line.append("")
                    else:
                        line.append(parsedDueDate.strftime("%Y-%m-%dT%H:%M:%S%z"))
                elif key == "startDate":
                    parsedStartDate = self.data["startDate"]
                    if parsedStartDate == None:
                        line.append("")
                    else:
                        line.append(parsedStartDate.strftime("%Y-%m-%dT%H:%M:%S%z"))
                elif key == "effort(hours)":
                    parsedEffortHours = self.data["effort(hours)"]
                    if parsedEffortHours == None:
                        line.append("")
                    else:
                        line.append(str(parsedEffortHours))
                else:
                    line.append(self.data[key])

            line += [""] * int(self.data["level"])
            line.append(self.data["cell"])
            outputArray.append(line)

        # Print children, recursively
        for child in self.childNodes:
            child.writeCSVTree(outputArray)

        return outputArray

    def getCounter(self, counter=None):
        """
        >>> csv_tree = CSVTree("icons", "shape", "colour", "note", 1, 1, "cell")
        >>> csv_tree.getCounter()
        Counter({1: 1})
        >>> _ = csv_tree.addChild(CSVTree("icons", "shape", "colour", "note", 2, 7, "cell"))
        >>> csv_tree.getCounter()
        Counter({1: 1, 2: 1})
        """
        counter = counter or Counter()
        counter[self.data["level"]] += 1
        for child in self.childNodes:
            child.getCounter(counter)
        return counter

    def checkHierarchy(self, actionsList):
        sys.stderr.write("Beginning Level Check\n")
        sys.stderr.write("---------------------\n")

        self._checkHierarchy(-2, actionsList)

        sys.stderr.write("---------------------\n")
        sys.stderr.write("Completed Level Check\n")

    def _checkHierarchy(self, previousLevel, actionsList):
        level = int(self.data["level"])
        if level > previousLevel + 1:
            sys.stderr.write(self.data["cell"].ljust(40) + " Error: ")
            sys.stderr.write(f"Expected level {previousLevel + 1}.")
            sys.stderr.write(f" Found level {level}. ")

            firstAction = actionsList[0]

            if firstAction in ("repair", "repairnode"):
                # Repair just this node
                self.data["level"] = previousLevel + 1
                sys.stderr.write(
                    f"Repaired, setting level to {previousLevel + 1}." + "\n"
                )
            elif firstAction == "repairsubtree":
                # Repair the whole subtree
                sys.stderr.write(
                    "Repaired this node (setting its level to "
                    f"{previousLevel + 1}) and all its child nodes." + "\n"
                )
                self.repairSubtreeLevels(previousLevel)
            elif firstAction == "stop":
                # Terminate the check
                sys.stderr.write("Terminating.\n")
                sys.exit()
            else:
                sys.stderr.write("\n")
        else:
            if previousLevel > -2:
                sys.stderr.write(self.data["cell"].ljust(40) + " OK:   ")
                sys.stderr.write(f" Found level {level}." + "\n")
        for childNode in self.childNodes:
            childNode._checkHierarchy(previousLevel + 1, actionsList)

    def repairSubtreeLevels(self, parentLevel):
        # Repair this level
        self.data["level"] = str(parentLevel + 1)

        # Repair lower levels
        for childNode in self.childNodes:
            childNode.repairSubtreeLevels(parentLevel + 1)

    def exportToIndentedText(self, actionsList):
        indentationType = actionsList[0].lower()
        if indentationType == "tab":
            indentationCharacters = "\t"
        if indentationType == "original":
            indentationCharacters = inputIndentCharacters
        elif indentationType == ".":
            indentationCharacters = "  "
        elif indentationType.startswith("space:"):
            spaceCount = int(indentationType[6:])
            indentationCharacters = " " * spaceCount
        else:
            indentationCharacters = indentationType

        return self._exportToIndentedText(indentationCharacters)

    def _exportToIndentedText(self, indentationCharacters):
        output = []

        level = int(self.data["level"])

        if level > -1:
            indentationText = indentationCharacters * level
            output.append(indentationText + self.data["cell"])

        for childNode in self.childNodes:
            output += childNode._exportToIndentedText(indentationCharacters)

        return output

    def exportToMarkdown(self, actionsList):
        # Get the number of heading levels to allow before going to nested bulleted
        # lists
        headingLevels = int(actionsList[0])

        if len(actionsList) > 1:
            # Get first heading level
            startingLevel = int(actionsList[1])
        else:
            # Default to starting at heading level 1
            startingLevel = 1

        return self._exportToMarkdown(headingLevels - 1, startingLevel)

    def _exportToMarkdown(self, maxHeadingLevel, startingLevel):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])
        if level > -1:
            note = self.data["note"]
            if level > maxHeadingLevel:
                output.append(
                    "  " * (level - maxHeadingLevel - startingLevel + 2)
                    + "* "
                    + self.data["cell"]
                )
                if note:
                    output.append(f"<br/><br/>{note}" + "\n")
            else:
                output.append(
                    "\n"
                    + "#" * (level + startingLevel)
                    + " "
                    + self.data["cell"]
                    + "\n"
                )
                if note:
                    output.append(note + "\n")

        for childNode in self.childNodes:
            output += childNode._exportToMarkdown(maxHeadingLevel, startingLevel)

        return output

    def exportToDotDigraph(self, actionsList):
        # Get the number of heading levels to allow before going to nested bulleted
        output, dummy = self._exportToDotDigraph(-1, 0)

        if actionsList[0][0:1] == "v":
            graphAttributes = "\n rankdir=TB"
        else:
            graphAttributes = "\n  rankdir=LR"

        output = ["digraph {" + graphAttributes] + output + ["}"]
        return output

    def _exportToDotDigraph(self, parentItemNumber, thisItemNumber):
        # Prime array of output lines
        output = []

        if thisItemNumber > 0:
            attributes = 'label="' + self.data["cell"] + '"'

            colour = self.data["colour"] or "FFFFFF"
            if colour == "FFFFFF":
                wantFilled = False
            else:
                wantFilled = True
                attributes = attributes + ',fillcolor="#' + colour + '"'

            shape = self.data["shape"]
            wantRounded = False
            if shape != "":
                if shape == "auto":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "rectangle":
                    attributes = attributes + ',shape="rectangle"'
                elif shape == "square":
                    attributes = attributes + ',shape="square"'
                elif shape == "rounded":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "pill":
                    attributes = attributes + ',shape="rectangle"'
                    wantRounded = True
                elif shape == "parallelogram":
                    attributes = attributes + ',shape="parallelogram"'
                elif shape == "diamond":
                    attributes = attributes + ',shape="diamond"'
                elif shape == "triangle":
                    attributes = attributes + ',shape="triangle"'
                elif shape == "oval":
                    attributes = attributes + ',shape="oval"'
                elif shape == "circle":
                    attributes = attributes + ',shape="circle"'
                elif shape == "underline":
                    attributes = attributes + ',shape="underline"'
                elif shape == "none":
                    attributes = attributes + ',shape="none"'
                elif shape == "square bracket":
                    attributes = attributes + ',shape="rectangle"'
                elif shape == "round bracket":
                    attributes = attributes + ',shape="ellipse"'
                else:
                    attributes = attributes + ',shape="rectangle"'

            if wantRounded | wantFilled:
                styles = []
                if wantRounded:
                    styles.append("rounded")
                if wantFilled:
                    styles.append("filled")
                attributes = attributes + ',style="' + ",".join(styles) + '"'

            output.append("  N" + str(thisItemNumber) + "[" + attributes + "]")
            if parentItemNumber > 0:
                output.append(
                    "  N" + str(parentItemNumber) + " -> N" + str(thisItemNumber)
                )

        nextItemNumber = thisItemNumber + 1
        for childNode in self.childNodes:
            returnedOutput, nextItemNumber = childNode._exportToDotDigraph(
                thisItemNumber, nextItemNumber
            )
            output += returnedOutput

        return output, nextItemNumber

    def calculateMaximumLevel(self, level=0):
        """
        maximum level is the max of this level and the levels of all childNodes,
        recursively through their descendents
        """
        thisLevel = int(self.data["level"])
        if thisLevel > level:
            level = thisLevel
        for childNode in self.childNodes:
            level = childNode.calculateMaximumLevel(level)
        return level

    def exportToHTML(self, actionsList):
        action = actionsList[0]

        # Prime array of output lines
        output = []

        if action == "table":

            # Work out how many levels are needed
            maximumLevel = self.calculateMaximumLevel()

            # Write table start
            output.append("<table>")

            # Get tree properties to figure out what columns to write
            treeProperties = self.getTreeProperties()

            # Put out headings - if needed
            if reduce(lambda a, b: bool(a or b), treeProperties):
                # At least one heading wanted
                (
                    hasNote,
                    hasPosition,
                    hasDueDate,
                    hasStartDate,
                    hasEffort,
                    hasPriority,
                    hasProgress,
                    hasIcon,
                    hasShape,
                ) = treeProperties

                output.append("<tr>")

                if hasDueDate:
                    output.append("<th class='duedate'>Due Date</th>")

                if hasStartDate:
                    output.append("<th class='startdate'>Start Date</th>")

                if hasEffort:
                    output.append("<th class='effort'>Effort<br/>(Hours)</th>")

                if hasPriority:
                    output.append("<th class='priority'>Priority</th>")

                if hasProgress:
                    output.append("<th class ='progress'>Progress<br/>&percnt;</th>")

                output.append("</tr>")
            # Write table rows
            output += self._exportToHTMLTable(maximumLevel, action, treeProperties)

            # Write table end
            output.append("</table>")
        else:
            # Write top-level list start
            output.append("<ul style='list-style-type: none;'>")

            # Write nested list
            level, freshOutput = self._exportToHTMLList(action)

            output += freshOutput

            # Write top-level list stop
            output.append("</ul>")

        return output

    def _exportToHTMLTable(self, maximumLevel, action, treeProperties):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])
        # Determine the cell background colour
        colour = self.data["colour"] or "FFFFFF"
        # HTML table
        if level > -1:
            # Print table row start
            output.append("<tr>")

            (
                hasNote,
                hasPosition,
                hasDueDate,
                hasStartDate,
                hasEffort,
                hasPriority,
                hasProgress,
                hasIcon,
                hasShape,
            ) = treeProperties

            # Print any required optional columns
            if hasDueDate:
                dueDate = self.data["dueDate"]
                output.append(
                    "<td class='duedate'>" + formatTaskpaperDatetime(dueDate) + "</td>"
                )

            if hasStartDate:
                startDate = self.data["startDate"]
                output.append(
                    "<td class='startDate'>"
                    + formatTaskpaperDatetime(startDate)
                    + "</td>"
                )

            if hasEffort:
                effort = self.data["effort(hours)"]
                if effort is None:
                    output.append("<td class='effort'></td>")
                else:
                    output.append("<td class='effort'>" + str(effort) + "</td>")

            if hasPriority:
                output.append("<td class='priority'>" + self.data["priority"] + "</td>")

            if hasProgress:
                output.append("<td class='progress'>" + self.data["progress"] + "</td>")

            # Print padding empty columns after the cell's column
            if level > 0:
                output.append("<td></td>" * level)

            # Print the cell itself, including styling
            output.append(
                "<td style='border: 1px solid black;border-radius: 5px;"
                + "background-color: #"
                + colour
                + ";'>"
                + self.data["cell"]
                + "</td>"
            )

            # Print padding empty columns after the cell's column
            if level < maximumLevel:
                output.append("<td></td>" * (maximumLevel - level))

            # Print any note as a final column
            note = self.data["note"]
            if note:
                output.append("<td>" + note + "</td>")

            # Print table row end
            output.append("</tr>")

        for childNode in self.childNodes:
            output += childNode._exportToHTMLTable(maximumLevel, action, treeProperties)

        return output

    def _exportToHTMLList(self, action):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        # Determine the cell background colour
        colour = self.data["colour"]
        if colour == "":
            colour = "FFFFFF"

        # Determine if there is a note
        note = self.data["note"]

        # HTML nested list
        if level > -1:
            indent = "  " * (level + 1)
            # print list item
            output.append(
                indent
                + "<li style='padding: 10px;'><span style='border: 1px solid "
                + "black;padding: 5px;border-radius: 5px;background-color: #"
                + colour
                + ";'>"
                + self.data["cell"]
                + "</span>"
            )

            # Print any note
            if note:
                output.append(indent + "  <br/><br/>" + note)

            needListElements = len(self.childNodes) > 0
            if needListElements is True:
                output.append(indent + "<ul style='list-style-type: none;'>")

        returnedLevel = -2
        for childNode in self.childNodes:
            returnedLevel, freshOutput = childNode._exportToHTMLList(action)

            output += freshOutput

        if level > -1:
            if needListElements is True:
                output.append(indent + "</ul>")

            output.append(indent + "</li>")

        return [level, output]

    def exportToXML(self, actionsList):
        action = actionsList[0]

        if action == "freemind":
            # Freemind XML export
            return self.exportToFreemindXML(actionsList)
        elif action == "opml":
            return self.exportToOPMLXML(actionsList)

    def exportToFreemindXML(self, actionsList):
        # Export to XML in the format Freemind, MindNode and iThoughts accept

        # Prime array of output lines
        output = []

        # Warn if resulting XML would produce more than 1 Level 0 node
        if len(self.childNodes) > 1:
            sys.stderr.write(
                "Exported XML will have more than 1 root node. Some programs will get "
                "confused by this. Continuing.\n"
            )

        # Start the map
        output.append("<?xml version='1.0'?>")
        output.append("<map>")

        # Recursively print the nodes
        output += self._exportToFreemindXML(actionsList)

        # Finish the map
        output.append("</map>")

        return output

    def _exportToFreemindXML(self, actionslist):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        if level > -1:
            # Print this node
            colour = self.data["colour"]
            cell = self.data["cell"]
            note = self.data["note"]
            indent = "  " * (level + 1)
            if colour == "":
                output.append(indent + "<node TEXT='" + cell + "'>")
            else:
                output.append(
                    indent
                    + "<node BACKGROUND_COLOR='#"
                    + colour
                    + "' TEXT='"
                    + cell
                    + "'>"
                )

            if note:
                output.append(indent + "  <richcontent TYPE='NOTE'><html>")
                output.append(indent + "    <head></head>")
                output.append(indent + "    <body>")
                output.append(indent + "      <p>")
                output.append(indent + "        " + note)
                output.append(indent + "      </p>")
                output.append(indent + "    </body>")

                output.append(indent + "  </richcontent>")

        for childNode in self.childNodes:
            output += childNode._exportToFreemindXML(actionsList)

        if level > -1:
            output.append(indent + "</node>")

        return output

    def exportToOPMLXML(self, actionsList):
        # Export to OPML XML

        # Prime array of output lines
        output = []

        # Warn if resulting XML would produce more than 1 Level 0 node
        if len(self.childNodes) > 1:
            sys.stderr.write(
                "Exported XML will have more than 1 root node. Some programs will get "
                "confused by this. Continuing.\n"
            )

        # Start the map
        output.append("<?xml version='1.0'?>")
        output.append("<opml version='2.0'>")
        output.append("  <head>")
        output.append("  </head>")
        output.append("  <body>")

        # Recursively output.append the nodes
        output += self._exportToOPMLXML(actionsList)

        # Finish the map
        output.append("  </body>")
        output.append("</opml>")

        return output

    def _exportToOPMLXML(self, actionslist):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])

        if level > -1:
            # Print this node
            colour = self.data["colour"]
            cell = self.data["cell"]
            note = self.data["note"]
            indent = "  " * (level + 2)
            if colour == "":
                printLine = indent + "<outline text='" + cell + "'"
            else:
                printLine = (
                    indent
                    + "<outline BACKGROUND_COLOR='#"
                    + colour
                    + "' text='"
                    + cell
                    + "'"
                )

            if note:
                printLine = printLine + " Note='" + note + "'"

            output.append(printLine + ">")

        for childNode in self.childNodes:
            output += childNode._exportToOPMLXML(actionsList)

        if level > -1:
            output.append(indent + "</outline>")

        return output

    def exportToTaskpaper(self, actionsList):
        # Get the number of heading levels to allow before going to nested bulleted
        # lists

        return self._exportToTaskpaper()

    def _exportToTaskpaper(self):
        # Prime array of output lines
        output = []

        level = int(self.data["level"])
        if level > -1:
            if level == 0:
                output.append(self.data["cell"] + ":")
            else:
                dueDate = self.data["dueDate"]
                if dueDate == None:
                    dueString = ""
                else:
                    dueString = " @due(" + formatTaskpaperDatetime(dueDate) + ")"

                startDate = self.data["startDate"]
                if startDate == None:
                    deferString = ""
                else:
                    deferString = " @defer(" + formatTaskpaperDatetime(startDate) + ")"

                effort = self.data["effort(hours)"]
                if effort == None:
                    effortString = ""
                else:
                    effortString = " @effort(" + str(effort) + ")"

                priority = self.data["priority"]
                if priority == "":
                    priorityString = ""
                else:
                    priorityString = " @priority(" + priority + ")"

                progress = self.data["progress"]
                if progress == "":
                    progressString = ""
                elif progress == "100":
                    progressString = " @done"
                else:
                    progressString = " @started"

                output.append(
                    "\t" * level
                    + "- "
                    + self.data["cell"]
                    + dueString
                    + deferString
                    + effortString
                    + priorityString
                    + progressString
                )

                noteText = self.data["note"]
                if noteText != "":
                    output.append("\t" * (level + 1) + noteText)

        for childNode in self.childNodes:
            output += childNode._exportToTaskpaper()

        return output

    def processKeep(self, matchCriterion):
        # Reset all nodes' matched flags
        self._markUnmatched()

        # Apply tests to each node and mark it and all its children and ancestors
        # matched
        self._processKeep(matchCriterion)

        # Delete any unmatched nodes
        self._deleteUnmarked()

    def _processKeep(self, matchCriterion):
        if self.isMatch(matchCriterion) is True:
            # mark self and all the ancestors matched
            self._markAncestorsMatched()

            # mark self and its subtree matched
            self._markSubtreeMatched()
        else:
            # Maybe children etc are matches
            for childNode in self.childNodes:
                childNode._processKeep(matchCriterion)

    def processAutocolour(self, matchCriterion):
        self._processAutocolour(matchCriterion, [])

    def _processAutocolour(self, matchCriterion, matchValues):
        if self.isMatch(matchCriterion) is True:
            # Process node as a match
            searchResult = matchCriterion.search(self.data["cell"])

            # Get key - tuple with match values for each group
            matchValue = searchResult.groups()

            # Handle whether key is a new key or existing
            if matchValue not in matchValues:
                # New colour
                matchValues.append(matchValue)

                colourNumber = len(matchValues)
            else:
                # Existing colour
                colourNumber = matchValues.index(matchValue) + 1
            self.data["colour"] = iThoughtsColours.getColour(colourNumber)

        # Maybe children etc are matches
        for childNode in self.childNodes:
            childNode._processAutocolour(matchCriterion, matchValues)

    def _markUnmatched(self):
        self.matched = False

        for childNode in self.childNodes:
            childNode._markUnmatched()

    def _markAncestorsMatched(self):
        if self.data["level"] > -1:
            self.matched = True
            self.parent._markAncestorsMatched()

    def _markSubtreeMatched(self):
        self.matched = True
        for childNode in self.childNodes:
            childNode._markSubtreeMatched()

    def _deleteUnmarked(self):
        for childNode in self.childNodes:
            childNode._deleteUnmarked()
        if self.data["level"] > -1:
            if not self.matched:
                self.parent.deleteChild(self)

    def promoteLevel(self, actionslist):
        # Promote everything at the specified level, deleting parents
        promotedLevel = int(actionslist[0])
        if promotedLevel < 1:
            sys.stderr.write("Cannot promote level " + str(promotedLevel) + "\n")
            sys.exit()

        # Get nodes to promote
        nodesToPromote = self.findNodesAtLevel(promotedLevel)

        # Get their parents, removing duplicates
        parentsToDelete = []
        for node in nodesToPromote:
            if node.parent not in parentsToDelete:
                parentsToDelete.append(node.parent)

        # Promote each parent's children
        for parent in parentsToDelete:
            # Insert each child in turn
            parentsParent = parent.parent
            for childNode in parent.childNodes:
                parentsParent.addChild(childNode)

            # Delete the parent
            parentsParent.deleteChild(parent)

        # Repair all the levels in the tree
        self.repairSubtreeLevels(-2)

    def findNodesAtLevel(self, level):
        # returns a list of nodes at a particular level
        return self._findNodesAtLevel(level, [])

    def _findNodesAtLevel(self, level, nodes):
        # recursive helper routine to search the tree for nodes at a certain level
        if self.data["level"] == level:
            nodes.append(self)
        else:
            for childNode in self.childNodes:
                nodes = childNode._findNodesAtLevel(level, nodes)

        return nodes
        
    def countMatches(self, matchCriterion):
    
        # Clear the matches for this match criterion
        #clearMatches()
        
        # Apply the matches, counting them
        if str(matchCriterion)[:3] == "re.":
            matchCount = self._countMatches(matchCriterion)
            pattern = f"RegEx { str(matchCriterion)[11:-1]}"
        else:
            matchCount = self.applyActions(matchCriterion,["justcount"])
            pattern = matchCriterion
        
        sys.stderr.write(f"Match count for {pattern}: {str(matchCount)}\n")
        
        # Return match count - which would be -1 if invalid
        return matchCount

    def _countMatches(self, matchCriterion):
    
        if self.isMatch(matchCriterion) is True:
            matchCount = 1
            self.matched = True
            self.matches += 1
        else:
            matchCount = 0
        
        for childNode in self.childNodes:
            matchCount += childNode._countMatches(matchCriterion)
            
        return matchCount

    def countUnmatched(self):
    
        # Clear the matches for this match criterion
        #clearMatches()
        
        # Apply the matches, counting them
        unmatchedCount = self._countUnmatched()
        
        if unmatchedCount < 0:
            unmatchedCount = 0
        sys.stderr.write(f"Remaining unmatched: {str(unmatchedCount)}\n")

    def _countUnmatched(self):
        if self.matched is True:
            unmatchedCount = 0
        else:
            unmatchedCount = 1
        
        for childNode in self.childNodes:
            unmatchedCount += childNode._countUnmatched()
            
        return unmatchedCount

    def writeStatistics(self, actionslist):
        # Write statistics in one of a number of formats

        # Prime array of output lines
        output = []

        # Get the statistics array
        statistics = self.getStatistics()

        # Output the statistics in the right format
        firstAction = actionslist[0]
        if firstAction == "csv":
            output.append("'Level','Nodes','Distinct Nodes'")

            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    str(level) + "," + str(levelNodes) + "," + str(distinctLevelNodes)
                )
        elif firstAction == "html":
            output.append("<table>")
            output.append(
                "<tr>\n<th>Level</th>\n<th>Nodes</th>\n<th>Distinct Nodes</th>\n</tr>"
            )
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append("<tr>")
                output.append("<td>" + str(level) + "</td>")
                output.append("<td>" + str(levelNodes) + "</td>")
                output.append("<td>" + str(distinctLevelNodes) + "</td>")
                output.append("</tr>")
            output.append("</table>")
        elif firstAction == "markdown":
            output.append("|Level|Nodes|Distinct Nodes|")
            output.append("|-:|-:|-:|")
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    "|"
                    + str(level)
                    + "|"
                    + str(levelNodes)
                    + "|"
                    + str(distinctLevelNodes)
                    + "|"
                )
        elif firstAction == "text":
            output.append("Level Nodes Distinct Nodes")
            for level in range(0, 21):
                levelNodes = statistics[0][level]
                if levelNodes == 0:
                    break
                distinctLevelNodes = statistics[1][level]
                output.append(
                    str(level).rjust(5, " ")
                    + " "
                    + str(levelNodes).rjust(5, " ")
                    + " "
                    + str(distinctLevelNodes).rjust(14, " ")
                )
        else:
            sys.stderr.write("Invalid format for 'stats': " + firstAction + "\n")

        return output

    def getStatistics(self):
        # Prime statistics arrays
        nodesAtLevel = []
        distinctNodeValuesAtLevel = []
        for level in range(0, 21):
            nodesAtLevel.append(0)
            distinctNodeValuesAtLevel.append([])

        # Walk the tree, updating statistics
        [nodesAtLevel, distinctNodeValuesAtLevel] = self._getStatistics(
            nodesAtLevel, distinctNodeValuesAtLevel
        )

        # Coalesce the sets of node values into counts
        distinctNodesAtLevel = []
        for level in range(0, 21):
            distinctNodesAtLevel.append(len(distinctNodeValuesAtLevel[level]))

        # Return the statistics:
        #    Count of nodes at each level
        #    Count of unique node values at each level
        return [nodesAtLevel, distinctNodesAtLevel]

    def _getStatistics(self, nodesAtLevel, distinctNodeValuesAtLevel):
        level = int(self.data["level"])
        if level > -1:
            # Increment count of nodes at this level
            nodesAtLevel[level] += 1

            # Add cell value to the list for this level - if it's not already in it
            cellValue = self.data["cell"]
            if cellValue not in distinctNodeValuesAtLevel[level]:
                distinctNodeValuesAtLevel[level].append(cellValue)

        for childNode in self.childNodes:
            [nodesAtLevel, distinctNodeValuesAtLevel] = childNode._getStatistics(
                nodesAtLevel, distinctNodeValuesAtLevel
            )

        return [nodesAtLevel, distinctNodeValuesAtLevel]

    def doHorizontalSpread(self, actionsList):
        self._doSpread("horizontal", actionsList)

    def doVerticalSpread(self, actionsList):
        self._doSpread("vertical", actionsList)

    def _doSpread(self, direction, actionsList):
        # Spread the level 0 nodes - either vertically or horizontally

        # Get the increment
        action = actionsList[0]
        if action.isdigit():
            increment = int(action)
        else:
            sys.stderr.write("Increment value is not a positive integer.\n")
            sys.exit()

        # Set iThoughtsSpread variables up
        if direction == "horizontal":
            iThoughtsSpread.resetHorizontalSpread(increment)
            iThoughtsSpread.resetVerticalSpread(0)
        else:
            iThoughtsSpread.resetHorizontalSpread(0)
            iThoughtsSpread.resetVerticalSpread(increment)

        for childNode in self.childNodes:
            childNode.data["position"] = (
                "{"
                + str(iThoughtsSpread.nextHorizontal())
                + ","
                + str(iThoughtsSpread.nextVertical())
                + "}"
            )

    def dump(self, actionsList=None) -> str:
        """
        >>> csv_tree = CSVTree("", "", "", "", "-1", "", "")
        >>> csv_child = CSVTree("", "square", "", "", "0", "", "Foo")
        >>> _ = csv_tree.addChild(csv_child)
        >>> print(csv_tree.dump([]).rstrip())
                                         -1
        square                           0                     Foo
        """
        s = "".join(
            f"{str(value)[:10]:<11}".replace("\n", "\\n")
            for value in self.data.values()
        )
        s = f"{'  ' * int(self.data['level'])}{s.rstrip()}" + "\n"
        return s + "".join(child.dump(actionsList) for child in self.getChildren())

    def dump2(self, treeLevel) -> str:
        s = (
            str(treeLevel)
            + " "
            + str(self.data["level"])
            + " "
            + self.data["cell"]
            + "\n"
        )
        return s + "".join(child.dump2(treeLevel + 1) for child in self.getChildren())

    def dumpAll(self):
        # Find root Node
        rootNode = self.parent
        while rootNode.parent is not None:
            rootNode = rootNode.parent

        # Dump from the root downwards
        return rootNode.dump2(-1)

    def makeAsBulletOfParent(self):
        if self.toBeDeleted:
            return

        # Acquire the parent
        if self.parent.data["level"] == -1:
            # Can't make this node a bullet under parent if parent is root i.e. level -1
            sys.stderr.write(f"Node {self.data['cell']} has no parent.\n")
        else:
            # Get parent cell value - to append to
            parentCellValue = self.parent.data["cell"]

            # Acquire this cell's value and add as a bullet to parent's cell value
            cellValue = self.data["cell"]
            newParentCellValue = parentCellValue + "\n" + "* " + cellValue

            # set parent's cell value to the newly augmented one
            self.parent.data["cell"] = newParentCellValue

            # Promote the nodes under this one, replacing it
            self.parent.replaceChild(self, self.childNodes)

    def sortKey(self, node):
        return node.data["cell"]

    def sortChildren(self):
        newChildren = self.childNodes.copy()
        newChildren.sort(reverse=False, key=self.sortKey)
        self.childNodes = newChildren

    def reverseChildren(self):
        newChildren = self.childNodes.copy()
        newChildren.reverse()
        self.childNodes = newChildren

    # Prints list of optional tree properties
    def printTreeProperties(self):
        (
            hasNote,
            hasPosition,
            hasDueDate,
            hasStartDate,
            hasEffort,
            hasPriority,
            hasProgress,
            hasIcon,
            hasShape,
        ) = self.getTreeProperties()

        sys.stderr.write("Properties\n----------\n")
        sys.stderr.write("Note: " + str(hasNote) + "\n")
        sys.stderr.write("Position: " + str(hasPosition) + "\n")
        sys.stderr.write("Due Date: " + str(hasDueDate) + "\n")
        sys.stderr.write("Start Date: " + str(hasStartDate) + "\n")
        sys.stderr.write("Effort: " + str(hasEffort) + "\n")
        sys.stderr.write("Priority: " + str(hasPriority) + "\n")
        sys.stderr.write("Progress: " + str(hasProgress) + "\n")
        sys.stderr.write("Icon: " + str(hasIcon) + "\n")
        sys.stderr.write("Shape: " + str(hasShape) + "\n")

        sys.stderr.write("\n")

    # Returns list of whether tree has any nodes with this property set in
    # any way - for each optional property
    def getTreeProperties(self):
        if self.data["note"] == "":
            hasNote = False
        else:
            hasNote = True

        if self.data["position"] == "":
            hasPosition = False
        else:
            hasPosition = True

        if self.data["dueDate"] == None:
            hasDueDate = False
        else:
            hasDueDate = True

        if self.data["startDate"] == None:
            hasStartDate = False
        else:
            hasStartDate = True

        if self.data["effort(hours)"] == None:
            hasEffort = False
        else:
            hasEffort = True

        if self.data["priority"] == "":
            hasPriority = False
        else:
            hasPriority = True

        if self.data["progress"] == "":
            hasProgress = False
        else:
            hasProgress = True

        if self.data["icons"] == "":
            hasIcon = False
        else:
            hasIcon = True

        if self.data["shape"] == "":
            hasShape = False
        else:
            hasShape = True

        for child in self.childNodes:
            (
                childHasNote,
                childHasPosition,
                childHasDueDate,
                childHasStartDate,
                childHasEffort,
                childHasPriority,
                childHasProgress,
                childHasIcon,
                childHasShape,
            ) = child.getTreeProperties()
            hasNote = hasNote | childHasNote
            hasPosition = hasPosition | childHasPosition
            hasDueDate = hasDueDate | childHasDueDate
            hasStartDate = hasStartDate | childHasStartDate
            hasEffort = hasEffort | childHasEffort
            hasPriority = hasPriority | childHasPriority
            hasProgress = hasProgress | childHasProgress
            hasIcon = hasIcon | childHasIcon
            hasShape = hasShape | childHasShape

        return (
            hasNote,
            hasPosition,
            hasDueDate,
            hasStartDate,
            hasEffort,
            hasPriority,
            hasProgress,
            hasIcon,
            hasShape,
        )


def formatWhitespaceCharacters(whitespace):
    """
    >>> formatWhitespaceCharacters("a b \\t c d")
    '<tab><space><tab><space><tab><space><tab><space><tab>'
    """
    # return "".join("<space>" if c == " " else "<tab>" for c in whitespace)
    return "".join(
        "<space>" if c == " " else "<newline>" if c == "\n" else "<tab>"
        for c in whitespace
    )


def writeOutput(printLines):
    for line in printLines:
        print(line, file=sys.stderr)


def formatTaskpaperDatetime(date):
    if date == None:
        return ""
    time = date.time()

    if time.hour + time.minute == 0:
        return date.strftime("%Y-%m-%d")
    else:
        return date.strftime("%Y-%m-%d %H:%M")


if __name__ == "__main__":
    if len(sys.argv) == 1:
        # No parameters so print help information and quit
        title = f"\nfilterCSV {filterCSV_level} - {filterCSV_date}"
        print(title)
        print("-" * (len(title) - 1))
        print(
            """
filterCSV is a tool for manipulating files for import into and export
from the iThoughtsX (Mac) and iThoughts (iOS / iPad OS app).

It can import and export other types of file as well. For details see
the README.md file on GitHub. This file is here:

    https://github.com/MartinPacker/filterCSV/blob/master/README.md

The filterCSV project is Open Sourced under the MIT licence. Its URL
is here:

    https://github.com/MartinPacker/filterCSV

In basic use filterCSV expects the following streams:

    stdin  (0) - The source file to be processed.

    stdout (1) - The resulting processed file.

    stderr (2) - Informational and error messages.

filterCSV also expects some commands. These are pairs of parameters.
Here is an example:

    filterCSV < input.csv > output.csv 'A1' 'triangle FF0000'

The first parameter specifies that any node whose text contains "A1"
is to be processed according to the second parameter.

The second parameter, which is enclosed in quotes because it contains
spaces, says to make the node's shape be a triangle and to colour it
red. ("FF0000" is the RGB value for red.)

For much more information see the README.md - which serves as the
manual.
        """
        )
        sys.exit()

    iThoughtsColours = iThoughtsColours()

    iThoughtsShapes = iThoughtsShapes()

    iThoughtsSpread = iThoughtsSpread()

    iThoughtsIcons = iThoughtsIcons()

    streamHandler = streamHandler()

    matchCriteria, actionsLists, output = ParameterParser().getParameters()

    writeOutput(output)

    #  Convert stdin data into CSV array - in whatever form it was
    (
        csvRows,
        colourColumn,
        levelColumn,
        noteColumn,
        shapeColumn,
        positionColumn,
        iconsColumn,
        progressColumn,
        priorityColumn,
        effortColumn,
        startColumn,
        dueColumn,
        output,
    ) = TreeReader().createCSVArray()

    writeOutput(output)

    # Build the tree from the CSV array
    currentLevel = -1
    csvTree = CSVTree("", "", "", "", "", "", "", "", "", currentLevel, "", "")
    currentNode = csvTree

    for rowNumber, row in enumerate(csvRows[1:]):
        # Extract information from this row
        level = int(row[levelColumn])
        shape = row[shapeColumn]
        colour = row[colourColumn]
        note = row[noteColumn]
        position = row[positionColumn]
        icons = row[iconsColumn]
        progress = row[progressColumn]
        priority = row[priorityColumn]
        effort = row[effortColumn]
        start = row[startColumn]
        due = row[dueColumn]

        cellValue = row[levelColumn + level + 1]

        if level > currentLevel:
            # New child of previous node
            currentLevel = level
            currentNode = currentNode.addChild(
                CSVTree(
                    due,
                    start,
                    effort,
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )
        elif level == currentLevel:
            # New sibling of previous node
            currentNode = currentNode.parent.addChild(
                CSVTree(
                    due,
                    start,
                    effort,
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )
        else:
            # Not a sibling or child of previous node
            currentLevel = level

            # Look for the true parent by backing up the tree
            parentNode = currentNode
            while int(parentNode.data["level"]) >= int(level):
                parentNode = parentNode.parent

            # Add the new node - now we've found the parent to add it to
            currentNode = parentNode.addChild(
                CSVTree(
                    due,
                    start,
                    effort,
                    priority,
                    progress,
                    icons,
                    shape,
                    colour,
                    note,
                    level,
                    position,
                    cellValue,
                )
            )

        currentNode.data["row"] = row

    # Statistics Header - For Matches and remaining unmatched
    sys.stderr.write("Match Statistics\n")
    sys.stderr.write("----------------\n")
    
    # Apply battery of parameter pairs to do the colouring etc.
    # (A row could match more than one and a later one overrides an earlier one)
    # In some cases the "match criterion" is a command and the "actions list"
    # contains parameters for that command. e.g. "markdown"
    matchesCount = -1
    for parmPair, matchCriterion in enumerate(matchCriteria):
        actionsList = actionsLists[parmPair]
        
        if (isinstance(matchCriterion, str)) and (matchCriterion.startswith("@")):
            csvTree.applyActions(matchCriterion, actionsList)
                
            # generate statistics
            matchesCount = csvTree.countMatches(matchCriterion)

        elif matchCriterion.pattern.lower() == "dump":
            sys.stderr.write(csvTree.dump(actionsList))

        elif actionsList[0] == "keep":
            csvTree.processKeep(matchCriterion)

        elif actionsList[0] in ["autocolour", "autocolor", "ac"]:
            csvTree.processAutocolour(matchCriterion)

        elif matchCriterion.pattern.lower() == "properties":
            csvTree.printTreeProperties()

        else:
            func = {
                "check": csvTree.checkHierarchy,
                "digraph": csvTree.exportToDotDigraph,
                "hspread": csvTree.doHorizontalSpread,
                "html": csvTree.exportToHTML,
                "markdown": csvTree.exportToMarkdown,
                "indented": csvTree.exportToIndentedText,
                "promote": csvTree.promoteLevel,
                "stats": csvTree.writeStatistics,
                "vspread": csvTree.doVerticalSpread,
                "xml": csvTree.exportToXML,
                "taskpaper": csvTree.exportToTaskpaper,
            }.get(matchCriterion.pattern.lower())

            if func:
                output = func(actionsList)
                if output:
                    print("\n".join(output))
                    sys.exit()
                # commands that generate no output fall through

            else:
                # This is where a node-level regular expression match would end up
                csvTree.applyActions(matchCriterion, actionsList)

                # It's possible some nodes were deleted so actually remove them
                csvTree.cleanUpDeleted()

                csvTree.repairSubtreeLevels(-2)
                
                # generate statistics
                matchesCount = csvTree.countMatches(matchCriterion)

    if matchesCount > -1:
        # Valid to print unmatched
        csvTree.countUnmatched()

    # Statistics Trailer - For Matches and remaining unmatched
    sys.stderr.write("----------------\n\n")


    TreeWriter().writeTreeAsCSV()
